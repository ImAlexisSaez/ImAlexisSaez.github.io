<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Presentación on Infinitos Contrastes</title>
    <link>https://imalexissaez.github.io/courses/python-basic/</link>
    <description>Recent content in Presentación on Infinitos Contrastes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Alexis Sáez &amp;copy;{year}</copyright>
    <lastBuildDate>Sun, 28 Apr 2019 00:01:00 +0000</lastBuildDate>
    
	<atom:link href="https://imalexissaez.github.io/courses/python-basic/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1. Presentación del curso</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb01-presentacion-del-curso/</link>
      <pubDate>Sun, 28 Apr 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb01-presentacion-del-curso/</guid>
      <description>Vídeo   Notas personales En este vídeo, se presenta el curso de Python y los motivos de su desarrollo. Después se revisa el temario, que aborda:
 Introducción. Requisitos previos. Instalación software. Fundamentos y sintaxis básica del lenguaje. POO con Python. Algoritmos, listas y tramos. BBDD. Trabajo con gráficos y contenidos. Procesos y tareas. Programación de red. Sockets. Ejercicios prácticos.  La lección termina con un breve apartado de FAQ.</description>
    </item>
    
    <item>
      <title>2. Introducción a Python</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb02-introduccion/</link>
      <pubDate>Sun, 28 Apr 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb02-introduccion/</guid>
      <description>Vídeo   Notas personales En este vídeo, se repasa la historia de Python y sus principales características. Entre ellas, destacan:
 Lenguaje interpretado de alto nivel, orientado a objetos, versátil y que es de código abierto. Gramática sencilla, clara y muy legible, con tipado dinámico y fuerte  A través de este enlace descargamos la última versión de Python (3.7.3 a la hora de escribir estas líneas). Si queremos la versión de 64 bits para Windows, hemos de buscarla en esta página.</description>
    </item>
    
    <item>
      <title>3. Sintaxis básica</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb03-sintaxis-basica/</link>
      <pubDate>Sun, 28 Apr 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb03-sintaxis-basica/</guid>
      <description>Vídeo   Notas personales En el IDLE de Python, tecleamos:
&amp;gt;&amp;gt;&amp;gt; print(&amp;quot;¡Hola mundo!&amp;quot;) # Esto es una instrucción ¡Hola mundo!  Usando ; escribimos varias instrucciones en una misma línea, aunque es desaconsejable por restar legibilidad.
&amp;gt;&amp;gt;&amp;gt; print(&amp;quot;¡Hola mundo!&amp;quot;); print(&amp;quot;¡Bienvenidos!&amp;quot;) ¡Hola mundo! ¡Bienvenidos!  Introducimos los comentarios con el símbolo # para:
 Anotar el código, facilitando futuros mantenimientos. Desactivar bloques de instrucciones, para localizar errores cometidos.  &amp;gt;&amp;gt;&amp;gt; # Esto es un comentario .</description>
    </item>
    
    <item>
      <title>4. Tipos, operadores y variables</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb04-tipos-y-variables/</link>
      <pubDate>Mon, 29 Apr 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb04-tipos-y-variables/</guid>
      <description>Vídeo   Notas personales Los tipos de datos disponibles en Python son:
 Numéricos  Enteros (int) Coma flotante (float) Complejos  Textos Booleanos  True False   Los principales operadores en Python son:
 Aritméticos: +, -, *, /, %, ** y //. Comparación: ==, !=, &amp;gt;, &amp;lt;, &amp;gt;= y &amp;lt;=. Lógicos: AND, OR y NOT. Asignación: =, +=, -=, *=, /=, %=, **= y //=. Especiales: is, is not, in y not in.</description>
    </item>
    
    <item>
      <title>5. Funciones I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb05-funciones-i/</link>
      <pubDate>Mon, 29 Apr 2019 00:01:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb05-funciones-i/</guid>
      <description>Vídeo   Notas personales Una función es un conjunto de líneas de código agrupadas, que funcionan como una unidad realizando una tarea específica. Puede devolver valores, tener parámetros o argumentos y recibe el nombre de método cuando está definida dentro de una clase.
En Python existen funciones predifinidas, como por ejemplo print(). Su principal utilidad es la reutilización de código y su sintaxis es:
def nombre(parámetros): instrucciones de la función return(opcional)  Ejecutamos (o llamamos) una función tecleando nombre_función(parámetros).</description>
    </item>
    
    <item>
      <title>6. Funciones II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb06-funciones-ii/</link>
      <pubDate>Mon, 29 Apr 2019 00:01:03 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb06-funciones-ii/</guid>
      <description>Vídeo   Notas personales Comencemos definiendo una función que suma dos números dados (5 y 7), mediante el mecanismo aprendido en la lección anterior:
def suma(): num1 = 5 num2 = 7 print(num1 + num2) suma()  Podemos reutilizar tantas veces como queramos la función suma(). No obstante, su utilidad así declarada es bastante limitada. Nos gustaría que no siempre sumara los dos mismos valores, sino aquellos que nos interesen en cada llamada.</description>
    </item>
    
    <item>
      <title>7. Listas</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb07-listas/</link>
      <pubDate>Mon, 29 Apr 2019 00:01:04 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb07-listas/</guid>
      <description>Vídeo   Notas personales Una lista es una estructura de datos que nos permite almacenar gran cantidad de valores. En Python, estos pueden añadirse de manera dinámica y ser de diferentes tipos.
Su sintaxis es nombre = [elem1, elem2, elem3...] y los elementos están localizados mediante un índice, que en Python comienza por 0.
A continuación, creemos una lista con cuatro elementos de tipo texto y veamos cómo imprimirla y acceder a elementos concretos de ella:</description>
    </item>
    
    <item>
      <title>8. Tuplas</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb08-tuplas/</link>
      <pubDate>Tue, 30 Apr 2019 00:01:00 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb08-tuplas/</guid>
      <description>Vídeo   Notas personales Una tupla es una lista inmutable que
 no permite añadir, eliminar, mover elementos&amp;hellip; permite la extracción de porciones, que continuan siendo tuplas, y posibilita búsquedas de índice (.index()) y comprobaciones de si un elemento pertenece o no a ella (in).  Son útiles porque
 son más rápidas en cuanto a ejecución se refiere, requieren menos espacio (mayor optimización), formatean cadenas de texto, y pueden utilizarse como claves en un diccionario, a diferencia de las listas.</description>
    </item>
    
    <item>
      <title>9. Diccionarios</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb09-diccionarios/</link>
      <pubDate>Tue, 30 Apr 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb09-diccionarios/</guid>
      <description>Vídeo   Notas personales Un diccionario es una estructura de datos que nos permite almacenar valores de diferentes tipos (enteros, cadenas de texto, decimales&amp;hellip;) e incluso listas, tuplas y otros diccionarios.
Su principal característica reside en que cada dato se almacena asociado a una clave única, de tal forma que se crea una relación de tipo clave:valor para cada elemento guardado. Además, los mencionados elementos no están ordenados, es decir, el orden es indiferente (por la presencia las referidas claves únicas) a la hora de guardar información en un diccionario.</description>
    </item>
    
    <item>
      <title>10. Condicionales I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb10-condicionales-i/</link>
      <pubDate>Tue, 30 Apr 2019 00:02:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb10-condicionales-i/</guid>
      <description>Vídeo   Notas personales Las estructuras condicionales nos permiten alterar el flujo de ejecución de un programa. Por lo que respecta al condicional if, tiene la siguiente sintaxis:
if condición: instrucciones  La anterior condición suele venir expresada a través de operadores de comparación (&amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, ==, !=). Veamos un sencillo ejemplo de aplicación de una estructura condicional if en la definición de una función:
def evaluacion(nota): valoracion = &amp;quot;Aprobado&amp;quot; if nota &amp;lt; 5: valoracion = &amp;quot;Suspenso&amp;quot; return valoracion print(evaluacion(6)) # Aprobado print(evaluacion(1)) # Suspenso print(evaluacion(2.</description>
    </item>
    
    <item>
      <title>11. Condicionales II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb11-condicionales-ii/</link>
      <pubDate>Tue, 30 Apr 2019 00:03:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb11-condicionales-ii/</guid>
      <description>Vídeo   Notas personales En este vídeo ampliaremos las posibilidades de la estructura condicional if mediante else y elif, quedando entonces su sintaxis como
if condicion: instrucciones elif condicion: instrucciones else: instrucciones  Empecemos creando un programa de control de acceso:
print(&amp;quot;Verificación de acceso&amp;quot;) edad_usuario = int(input(&amp;quot;Introduce tu edad: &amp;quot;)) if edad_usuario &amp;lt; 18: print(&amp;quot;No puedes pasar.&amp;quot;) else: print(&amp;quot;Puedes pasar.&amp;quot;)  Veamos el resultado de algunas ejecuciones de este programa:</description>
    </item>
    
    <item>
      <title>12. Condicionales III</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb12-condicionales-iii/</link>
      <pubDate>Wed, 01 May 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb12-condicionales-iii/</guid>
      <description>Vídeo   Notas personales Aunque en Python no existe una instrucción de tipo switch, como en otros lenguajes de programación, veremos que, gracias a la concatenación de operadores de comparación, a los operadores lógicos and y or, y al operador in, disponemos de bastante versatilidad a la hora de trabajar con estructuras condicionales.
Antes de nada, siguiendo las instrucciones de este post, creamos un atajo para ejecutar de manera más ágil nuestros programas.</description>
    </item>
    
    <item>
      <title>13. Condicionales IV</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb13-condicionales-iv/</link>
      <pubDate>Wed, 01 May 2019 00:02:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb13-condicionales-iv/</guid>
      <description>Vídeo   Notas personales A continuación, veremos el uso de los operadores lógicos and y or, y del operador in. Para ello, crearemos un programa que evalúe si un alumno tiene o no derecho a beca, dependiendo de
 la distancia a la que vive del centro, el número de hermanos, y el salario familiar.  print(&amp;quot;Programa de evaluación de becas - Curso 2018/19&amp;quot;) dist_escuela = int(input(&amp;quot;Introduce la distancia a la escuela (en km): &amp;quot;)) print(&amp;quot;Distancia a la escuela: &amp;quot; + str(dist_escuela)) num_hermanos = int(input(&amp;quot;Introduce el número de hermanos en el centro: &amp;quot;)) print(&amp;quot;Número de hermanos: &amp;quot; + str(num_hermanos)) sal_familiar = int(input(&amp;quot;Introduce el salario anual bruto: &amp;quot;)) print(&amp;quot;Salario anual bruto: &amp;quot; + str(sal_familiar)) if dist_escuela &amp;gt; 40 and num_hermanos &amp;gt; 2 and sal_familiar &amp;lt;= 20000: print(&amp;quot;Tienes derecho a beca&amp;quot;) else: print(&amp;quot;No tienes derecho a beca&amp;quot;)  Revisemos la estrutura condicional para que no sea tan complicado tener derecho a una beca:</description>
    </item>
    
    <item>
      <title>14. Bucles I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb14-bucles-i/</link>
      <pubDate>Wed, 01 May 2019 00:02:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb14-bucles-i/</guid>
      <description>Vídeo   Notas personales Abordaremos ahora otro tipo de estructura de control de flujo (las estructuras condicionales asimismo lo eran): los bucles.
La utilidad de un bucle es repetir una o varias líneas de código tantas veces como sea preciso (siendo esta cantidad conocida de antemano o no). En Python tenemos dos tipos de bucles:
 determinados: sabemos a priori cuántas veces se repetirá el bloque de código, e indeterminados: desconocemos a priori el número de repeticiones del bloque de código.</description>
    </item>
    
    <item>
      <title>15. Bucles II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb15-bucles-ii/</link>
      <pubDate>Thu, 02 May 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb15-bucles-ii/</guid>
      <description>Vídeo   Notas personales Las instrucciones print() que aparecen en los bucles de tipo for insertan un salto de línea en cada iteración:
for i in [&amp;quot;Píldoras&amp;quot;, &amp;quot;Informáticas&amp;quot;, 3]: print(&amp;quot;Hola&amp;quot;) # Hola # Hola # Hola  Si deseamos que la impresión se produzca en la misma línea, hemos de declarar adecuadamente el argumento end de la función print():
for i in [&amp;quot;Píldoras&amp;quot;, &amp;quot;Informáticas&amp;quot;, 3]: print(&amp;quot;Hola&amp;quot;, end=&amp;quot; &amp;quot;) # Hola Hola Hola  Si el elemento a recorrer es una cadena de texto, el bucle for ejecutará tantas iteraciones como letras tenga esta:</description>
    </item>
    
    <item>
      <title>16. Bucles III</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb16-bucles-iii/</link>
      <pubDate>Thu, 02 May 2019 00:02:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb16-bucles-iii/</guid>
      <description>Vídeo   Notas personales Veamos algunas opciones de la función print() a la hora de imprimir el valor de variables durante la ejecución de un bucle:
for i in range(5): print(f&amp;quot;valor de la variable {i}&amp;quot;) # valor de la variable 0 # valor de la variable 1 # valor de la variable 2 # valor de la variable 3 # valor de la variable 4  La f que aparece antes del texto entrecomillado indica el uso de funciones f, que permiten interesantes opciones de cara a la impresión de textos en la consola.</description>
    </item>
    
    <item>
      <title>17. Bucles IV</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb17-bucles-iv/</link>
      <pubDate>Fri, 03 May 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb17-bucles-iv/</guid>
      <description>Vídeo   Notas personales Estudiemos el bucle while, que es tipo indeterminado porque no sabemos a priori cuántas veces ejecutará el bloque de código contenido en su interior. Su sintaxis es:
while condición: instrucciones  En el siguiente ejemplo, no obstante, vemos cómo programar un bucle while para que funcione como uno de tipo determinado:
i = 1 while i &amp;lt;= 10: print(f&amp;quot;Iteración: {i}.&amp;quot;) i += 1 print(&amp;quot;Fin de ejecución del bucle while.</description>
    </item>
    
    <item>
      <title>18. Bucles V</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb18-bucles-v/</link>
      <pubDate>Sun, 05 May 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb18-bucles-v/</guid>
      <description>Vídeo   Notas personales En esta lección, abordaremos el uso de las instrucciones:
 continue: provoca que el flujo de ejecución de un programa, dentro de un bucle, salte a la siguiente iteración de este. pass: en cuanto se lee en el interior de un bucle, devuelve null (es como si no ejecutara el bucle). Su uso es reducido, salvo en definición de clases o casos muy concretos (dejar bucles vacíos, que sabemos serán precisos, para programar en un futuro próximo).</description>
    </item>
    
    <item>
      <title>19. Generadores I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb19-generadores-i/</link>
      <pubDate>Sun, 05 May 2019 00:02:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb19-generadores-i/</guid>
      <description>Vídeo   Notas personales Un generador es una estructura que extrae valores de una función y los almacena, de uno en uno, en objetos iterables (que se pueden recorrer). Cada vez que un generador almacena un valor, permanece en un estado pausado hasta que se solicita el siguiente, característica que se conoce como suspensión de estado.
La utilidad de los generadores reside en que:
 son más eficientes que las funciones tradicionales (sobretodo en consumo de recursos y tiempo, al no tener que construir &amp;ldquo;estructuras completas de datos&amp;rdquo;); resultan muy útiles con listas de valores infinitos; y bajo determinados escenarios, será recomendable que un generador devuelva los valores de uno en uno.</description>
    </item>
    
    <item>
      <title>20. Generadores II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb20-generadores-ii/</link>
      <pubDate>Sun, 05 May 2019 00:03:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb20-generadores-ii/</guid>
      <description>Vídeo   Notas personales Estudiemos el uso de la instrucción yield from, cuya utilidad reside en la simplificación del código de los generadores en el caso de utilizar bucles anidados.
Por ejemplo, elaboremos un generador que nos devuelva ciudades:
def devuelve_ciudades(*ciudades): for elemento in ciudades: yield elemento # Creamos objeto generador ciudades_devueltas = devuelve_ciudades(&amp;quot;Madrid&amp;quot;, &amp;quot;Barcelona&amp;quot;, &amp;quot;Bilbao&amp;quot;, &amp;quot;Valencia&amp;quot;) print(next(ciudades_devueltas)) # Madrid print(next(ciudades_devueltas)) # Barcelona  Nota: en Python, cuando colocamos un * delante de un parámetro, estamos indicando que podemos pasar un número indeterminado de argumentos, que los recibirá en forma de tupla.</description>
    </item>
    
    <item>
      <title>21. Excepciones I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb21-excepciones-i/</link>
      <pubDate>Mon, 06 May 2019 00:01:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb21-excepciones-i/</guid>
      <description>Vídeo   Notas personales Una excepción es un error que acontece durante la ejecución de un programa. La sintaxis del código es correcta, pero, en el momento de ejecutarse el algoritmo, sucede &amp;ldquo;algo inesperado&amp;rdquo;.
Para ilustrar la aparición de excepciones, trabajemos con el siguiente código:
def suma(num1, num2): return num1 + num2 def resta(num1, num2): return num1 - num2 def multiplica(num1, num2): return num1 * num2 def divide(num1, num2): return num1 / num2 op1 = (int(input(&amp;quot;Introduce el primer número: &amp;quot;))) op2 = (int(input(&amp;quot;Introduce el segundo número: &amp;quot;))) print(&amp;quot;Operaciones disponibles: &amp;quot;) print(&amp;quot;- Suma&amp;quot;) print(&amp;quot;- Resta&amp;quot;) print(&amp;quot;- Multiplica&amp;quot;) print(&amp;quot;- Divide&amp;quot;) operacion = input(&amp;quot;Introduce la operación a realizar: &amp;quot;) if operacion == &amp;quot;Suma&amp;quot;: print(suma(op1, op2)) elif operacion == &amp;quot;Resta&amp;quot;: print(resta(op1, op2)) elif operacion == &amp;quot;Multiplica&amp;quot;: print(multiplica(op1, op2)) elif operacion == &amp;quot;Divide&amp;quot;: print(divide(op1, op2)) else: print(&amp;quot;Operación no contemplada.</description>
    </item>
    
    <item>
      <title>22. Excepciones II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb22-excepciones-ii/</link>
      <pubDate>Mon, 06 May 2019 00:02:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb22-excepciones-ii/</guid>
      <description>Vídeo   Notas personales Recordemos el código final de la lección anterior:
def suma(num1, num2): return num1 + num2 def resta(num1, num2): return num1 - num2 def multiplica(num1, num2): return num1 * num2 def divide(num1, num2): try: return num1 / num2 except ZeroDivisionError: print(&amp;quot;No se puede dividir entre 0.&amp;quot;) return &amp;quot;Operación errónea.&amp;quot; op1 = (int(input(&amp;quot;Introduce el primer número: &amp;quot;))) op2 = (int(input(&amp;quot;Introduce el segundo número: &amp;quot;))) print(&amp;quot;Operaciones disponibles: &amp;quot;) print(&amp;quot;- Suma&amp;quot;) print(&amp;quot;- Resta&amp;quot;) print(&amp;quot;- Multiplica&amp;quot;) print(&amp;quot;- Divide&amp;quot;) operacion = input(&amp;quot;Introduce la operación a realizar: &amp;quot;) if operacion == &amp;quot;Suma&amp;quot;: print(suma(op1, op2)) elif operacion == &amp;quot;Resta&amp;quot;: print(resta(op1, op2)) elif operacion == &amp;quot;Multiplica&amp;quot;: print(multiplica(op1, op2)) elif operacion == &amp;quot;Divide&amp;quot;: print(divide(op1, op2)) else: print(&amp;quot;Operación no contemplada.</description>
    </item>
    
    <item>
      <title>23. Excepciones III</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb23-excepciones-iii/</link>
      <pubDate>Tue, 07 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb23-excepciones-iii/</guid>
      <description>Vídeo   Notas personales Estudiemos cómo lanzar excepciones, de forma intencionada, a través de la instrucción raise. Veremos su utilidad cuando trabajemos, más adelante, con clases.
Generemos un sencillo programa cuyo objetivo sea evaluar nuestra edad:
def evalua_edad(edad): if edad &amp;lt; 20: return &amp;quot;Eres muy joven.&amp;quot; elif edad &amp;lt; 40: return &amp;quot;Eres joven.&amp;quot; elif edad &amp;lt; 65: return &amp;quot;Eres maduro.&amp;quot; elif edad &amp;lt; 100: return &amp;quot;Cuídate.&amp;quot; print(evalua_edad(18)) # Eres muy joven.</description>
    </item>
    
    <item>
      <title>24. Programación orientada a objetos I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb24-poo-i/</link>
      <pubDate>Wed, 08 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb24-poo-i/</guid>
      <description>Vídeo   Notas personales Python es un lenguaje de programación orientado a objetos (POO). Existen, principalemente, dos paradigmas de programación:
 Programación orientada a procedimientos. Programación orientada a objetos.  Programación orientada a procedimientos Algunos ejemplos de lenguajes de programación que siguen este paradigma son: Fortan, Cobol, Basic&amp;hellip;
Entre sus principales desventajas encontramos:
 Las unidades de código son muy grandes en aplicaciones complejas (resultando en un número de líneas significativamente elevado).</description>
    </item>
    
    <item>
      <title>25. Programación orientada a objetos II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb25-poo-ii/</link>
      <pubDate>Wed, 08 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb25-poo-ii/</guid>
      <description>Vídeo   Notas personales Una clase es un modelo donde se redactan las características comunes de un grupo de objetos.
Una instancia (o ejemplar u objeto) es un miembro concreto de una clase.
La modularización surge cuando un programa está compuesto de diversas clases. Cada una de ellas funciona de manera independiente (facilitando así enormemente su mantenimiento y control de excepciones) y es posible su reutilización en otros programas.</description>
    </item>
    
    <item>
      <title>26. Programación orientada a objetos III</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb26-poo-iii/</link>
      <pubDate>Wed, 08 May 2019 00:00:03 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb26-poo-iii/</guid>
      <description>Vídeo   Notas personales Traslademos a código fuente algunos de los conceptos examinados en las dos lecciones anteriores. La sintaxis para crear la clase Coche sería:
class Coche(): instrucciones  Empecemos declarando las propiedades de la clase Coche:
class Coche(): largo_chasis = 250 ancho_chasis = 120 ruedas = 4 en_marcha = False  Definamos comportamientos para los futuros objetos que pertenezcan a esta clase, que vienen determinados por distintos métodos:</description>
    </item>
    
    <item>
      <title>27. Programación orientada a objetos IV</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb27-poo-iv/</link>
      <pubDate>Thu, 09 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb27-poo-iv/</guid>
      <description>Vídeo   Notas personales Partamos del código del último ejemplo de la lección anterior:
class Coche(): largo_chasis = 250 ancho_chasis = 120 ruedas = 4 en_marcha = False def arrancar(self): self.en_marcha = True def estado(self): if self.en_marcha: return &amp;quot;El coche está en marcha.&amp;quot; else: return &amp;quot;El coche está parado.&amp;quot;  Generemos dos objetos y comparémoslos:
mi_coche1 = Coche() mi_coche2 = Coche() print(&amp;quot;Largo mi_coche1: &amp;quot;, mi_coche1.largo_chasis) # Largo mi_coche1: 250 print(&amp;quot;Largo mi_coche2: &amp;quot;, mi_coche2.</description>
    </item>
    
    <item>
      <title>28. Programación orientada a objetos V</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb28-poo-v/</link>
      <pubDate>Thu, 09 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb28-poo-v/</guid>
      <description>Vídeo   Notas personales A continuación, abordaremos la encapsulación de métodos partiendo del último ejemplo de la lección anterior:
class Coche(): def __init__(self): self.__largo_chasis = 250 self.__ancho_chasis = 120 self.__ruedas = 4 self.__en_marcha = False def arrancar(self, arrancamos): self.__en_marcha = arrancamos if self.__en_marcha: return &amp;quot;El coche está en marcha.&amp;quot; else: return &amp;quot;El coche está parado.&amp;quot; def estado(self): print(&amp;quot;El coche tiene&amp;quot;, self.__ruedas, &amp;quot;ruedas. Un ancho de&amp;quot;, self.__ancho_chasis, &amp;quot;cm y un largo de&amp;quot;, self.</description>
    </item>
    
    <item>
      <title>29. Programación orientada a objetos VI</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb29-poo-vi/</link>
      <pubDate>Thu, 09 May 2019 00:00:03 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb29-poo-vi/</guid>
      <description>Vídeo   Notas personales En programación orientada a objetos, el concepto de herencia intenta dar una réplica aproximada de su contrapartida en la vida real. De una clase, denominada en ocasiones clase padre o superclase, heredarán otras clases atributos, métodos&amp;hellip; Se conocen estas últimas como subclases de la anterior (y también como superclases si de ellas también heredan otras).
La principal utilidad de la herencia es la reutilización de código cuando se generan clases &amp;ldquo;similares&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>30. Programación orientada a objetos VII</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb30-poo-vii/</link>
      <pubDate>Thu, 09 May 2019 00:00:04 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb30-poo-vii/</guid>
      <description>Vídeo   Notas personales Continuemos con el ejemplo de la lección anterior:
# Clase Padre class Vehiculo(): def __init__(self, marca, modelo): self.marca = marca self.modelo = modelo self.enmarcha = False self.acelera = False self.frena = False def arrancar(self): self.enmarcha = True def acelerar(self): self.acelera = True def frenar(self): self.frena = True def estado(self): print(&amp;quot;Marca:&amp;quot;, self.marca, &amp;quot;\nModelo:&amp;quot;, self.modelo, &amp;quot;\nEn marcha:&amp;quot;, self.enmarcha, &amp;quot;\nAcelerando:&amp;quot;, self.acelera, &amp;quot;\nFrenando:&amp;quot;, self.frena) # Clase hija class Moto(Vehiculo): pass  Construyamos la clase Moto, añadiendo un comportamiento nuevo, caballito, que se va a sumar a los cuatro heredados de la clase Vehiculo:</description>
    </item>
    
    <item>
      <title>31. Programación orientada a objetos VIII</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb31-poo-viii/</link>
      <pubDate>Fri, 10 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb31-poo-viii/</guid>
      <description>Vídeo   Notas personales En esta lección estudiaremos el uso de las funciones
 super() e isinstance().  Partimos del último ejemplo de la lección anterior:
class Vehiculo(): def __init__(self, marca, modelo): self.marca = marca self.modelo = modelo self.enmarcha = False self.acelera = False self.frena = False def arrancar(self): self.enmarcha = True def acelerar(self): self.acelera = True def frenar(self): self.frena = True def estado(self): print(&amp;quot;Marca:&amp;quot;, self.marca, &amp;quot;\nModelo:&amp;quot;, self.modelo, &amp;quot;\nEn marcha:&amp;quot;, self.</description>
    </item>
    
    <item>
      <title>32. Programación orientada a objetos IX</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb32-poo-ix/</link>
      <pubDate>Fri, 10 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb32-poo-ix/</guid>
      <description>Vídeo   Notas personales En esta lección, abordaremos el concepto de polimorfismo. Un objeto puede cambiar de forma dependiendo del contexto en el que se utilice y, por tanto, modificar tanto sus propiedades como sus comportamientos asociados.
Como Python es un lenguaje de tipado dinámico, esta característica es sencilla de utilizar.
Veamos un ejemplo:
class Coche(): def desplazamiento(self): print(&amp;quot;Me desplazo utilizando cuatro ruedas.&amp;quot;) class Moto(): def desplazamiento(self): print(&amp;quot;Me desplazo utilizando dos ruedas.</description>
    </item>
    
    <item>
      <title>33. Métodos de cadenas</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb33-cadenas/</link>
      <pubDate>Sat, 11 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb33-cadenas/</guid>
      <description>Vídeo   Notas personales Examinemos algunos de los métodos disponibles en Python a la hora de trabajar con cadenas de texto, que son objetos de tipo String. Entre los más habituales encontramos:
 upper() lower() capitalize() count() find() isdigit() isalum() isalpha() split() strip() replace() rfind()  Para obtener más información sobre su utilización, conviene que visitemos esta página.
Veamos algunos ejemplos sencillos que ilustren el uso de algunos de los anteriores métodos:</description>
    </item>
    
    <item>
      <title>34. Módulos</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb34-modulos/</link>
      <pubDate>Sun, 12 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb34-modulos/</guid>
      <description>Vídeo   Notas personales Un módulo es un archivo con extensión .py, .pyc (Python compilado) o fichero escrito en C para CPython, que posee su propio espacio de nombres y que puede contener variables, funciones, clases e incluso otros módulos.
Sirve para organizar y reutilizar el código (modularización y reutilización). Se genera uno creando un archivo con extensión .py (o .pyc o archivo en C) y guardándolo donde nos interese.</description>
    </item>
    
    <item>
      <title>35. Paquetes I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb35-paquetes-i/</link>
      <pubDate>Sun, 12 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb35-paquetes-i/</guid>
      <description>Vídeo   Notas personales Los paquetes son directorios donde se almacenarán módulos relacionados entre sí. Sirven para organizar el código de una aplicación y reutilizar los mencionados módulos.
Un paquete se crea generando un directorio en cuyo interior haya presente un archivo denominado __init__.py.
Imaginemos que nuestro objetivo es elaborar un programa que realice diversos cálculos matemáticos y estadísticos. Vamos a empezar creando un directorio denominado calculos, en consonancia con la nomenclatura que estamos siguiendo para los ficheros del repositorio.</description>
    </item>
    
    <item>
      <title>36. Paquetes distribuibles</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb36-paquetes-ii/</link>
      <pubDate>Mon, 13 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb36-paquetes-ii/</guid>
      <description>Vídeo   Notas personales Veamos cómo crear paquetes distribuibles para que otras personas puedan utilizar nuestro código fuente. El proceso a seguir se reduce a dos sencillos pasos:
 Crear el paquete. Instalar el paquete.  En la lección anterior generamos el paquete calculos como una carpeta en el interior del directorio del repositorio donde estamos almacenando todos los archivos de este curso. Desde la raíz del mencionado directorio, utilizamos los módulos contenidos en dicho paquete en, por ejemplo, paquetes_1.</description>
    </item>
    
    <item>
      <title>37. Archivos I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb37-archivos-i/</link>
      <pubDate>Tue, 14 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb37-archivos-i/</guid>
      <description>Vídeo   Notas personales En esta lección abordaremos cómo trabajar con ficheros externos de texto, utilizando para tal empresa el módulo io. Nuestro objetivo será conseguir la persistencia de datos, es decir, salvaguardar los datos que estamos manipulando para que no se pierdan al finalizar una sesión de Python.
Existen dos alternativas para conseguir el mencionado objetivo:
 Manejar archivos externos. Trabajar con bases de datos (BBDD).  Las fases necesarias para guardar cierta información en archivos externos son:</description>
    </item>
    
    <item>
      <title>38. Archivos II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb38-archivos-ii/</link>
      <pubDate>Tue, 14 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb38-archivos-ii/</guid>
      <description>Vídeo   Notas personales Continuemos el estudio de la manipulación de ficheros externos de texto, con el módulo io, analizando en esta ocasión cómo manejar punteros en texto.
Para ello, movamos el último archivo de texto generado en la lección anterior (archivo2.txt) a la carpeta, para así mantener la coherencia de la estructura de ficheros del repositorio. Tras ello, tecleemos:
from io import open archivo = open(&amp;quot;archivo2.txt&amp;quot;, &amp;quot;r&amp;quot;) print(archivo.</description>
    </item>
    
    <item>
      <title>39. Serialización I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb39-serializacion-i/</link>
      <pubDate>Wed, 15 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb39-serializacion-i/</guid>
      <description>Vídeo   Notas personales En esta lección estudiaremos cómo serializar colecciones de ciertos objetos. La serialización consiste en guardar en un fichero externo una lista, un diccionario o, incluso, un objeto; con la particularidad de que la codificación de dicho fichero es binaria.
Esta estrategia resulta de utilidad a la hora de compartir archivos por Internet, ya que su distribución es más sencilla, o bien si deseamos guardarlo en un dispositivo de almacenamiento externo o en una base de datos.</description>
    </item>
    
    <item>
      <title>40. Serialización II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb40-serializacion-ii/</link>
      <pubDate>Thu, 16 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb40-serializacion-ii/</guid>
      <description>Vídeo   Notas personales En esta lección, continuaremos estudiando el tema de la serialización, analizando ahora cómo llevar a cabo el proceso cuando hay objetos implicados.
Aprovechemos la clase Vehiculo que generamos anteriormente y cuyo código fuente recordemos era:
class Vehiculo(): def __init__(self, marca, modelo): self.marca = marca self.modelo = modelo self.enmarcha = False self.acelera = False self.frena = False def arrancar(self): self.enmarcha = True def acelerar(self): self.acelera = True def frenar(self): self.</description>
    </item>
    
    <item>
      <title>41. Guardado permanente</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb41-guardado-permanente/</link>
      <pubDate>Mon, 20 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb41-guardado-permanente/</guid>
      <description>Vídeo   Notas personales En esta lección, continuaremos estudiando cómo guardar datos de forma permanente en ficheros externos, reforzando así los contenidos aprendidos hasta el momento.
Empecemos importando la librería pickle y creando una clase sencilla: Persona.
import pickle class Persona: def __init__(self, nombre, genero, edad): self.nombre = nombre self.genero = genero self.edad = edad print(&amp;quot;Se ha creado una persona nueva con el nombre de&amp;quot;, self.nombre) def __str__(self): return &amp;quot;{} {} {}&amp;quot;.</description>
    </item>
    
    <item>
      <title>42. Interfaces gráficas I</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb42-interfaces-graficas-i/</link>
      <pubDate>Mon, 20 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb42-interfaces-graficas-i/</guid>
      <description>Vídeo   Notas personales En esta lección, comenzamos el estudio de las interfaces gráficas en Python, analizando para ello la librería Tkinter. Las interfaces gráficas, también denominadas GUI, son intermediarios entre el programa y el usuario. Están formadas por un conjunto de gráficos como ventanas, botones, menús, casillas de verificación, etc.
Además de la mencionada, existen otras librerías alternativas para trabajar con interfaces gráficas:
 WxPython PyQT PyGTK  Tkinter es un &amp;ldquo;puente&amp;rdquo; entre Python y la librería TCL / TK.</description>
    </item>
    
    <item>
      <title>43. Interfaces gráficas II</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb43-interfaces-graficas-ii/</link>
      <pubDate>Tue, 21 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb43-interfaces-graficas-ii/</guid>
      <description>Vídeo   Notas personales Después de introducir, en la lección anterior, la raíz de una interfaz gráfica, en esta abordaremos la construcción y uso de frames. Comencemos recuperando el código fuente de la &amp;ldquo;aplicación&amp;rdquo; que generamos con anterioridad:
from tkinter import Tk raiz = Tk() raiz.title(&amp;quot;Ventana de pruebas&amp;quot;) raiz.resizable(width=False, height=False) # raiz.resizable(0, 0) raiz.iconbitmap(&amp;quot;icon.ico&amp;quot;) raiz.geometry(&amp;quot;450x300&amp;quot;) raiz.config(bg=&amp;quot;lightblue&amp;quot;) raiz.mainloop()  A continuación, crearemos un frame y lo empaquetaremos (ubicaremos) dentro de la raíz disponible a través del método pack().</description>
    </item>
    
    <item>
      <title>44. Interfaces gráficas III</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb44-interfaces-graficas-iii/</link>
      <pubDate>Tue, 21 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb44-interfaces-graficas-iii/</guid>
      <description>Vídeo   Notas personales En esta lección, analizaremos cómo trabajar con el widget Label, perteneciente a la librería tkinter, que nos permite mostrar texto o imágenes en nuestras interfaces gráficas. No es un elemento con el que podamos interactuar, es decir, no podremos borrarlo, arrastrarlo, etc.
Su sintaxis es:
variable = Label(contenedor, opciones)  En esta página podemos consultar qué opciones disponibles ofrece el widget Label.
Para ver en acción este widget, reutilicemos como base parte del código generado en lecciones anteriores:</description>
    </item>
    
    <item>
      <title>45. Interfaces gráficas IV</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb45-interfaces-graficas-iv/</link>
      <pubDate>Wed, 22 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb45-interfaces-graficas-iv/</guid>
      <description>Vídeo   Notas personales En esta lección, tras haber estudiado en la anterior el widget Label, abordaremos el uso del widget Entry, cuyo funcionamento es realmente similar a nivel de sintaxis. Este último habilita, en nuestras ventanas, la posibilidad de introducir un cuadro de texto, desde el cual el usuario puede suministrar cierta información.
from tkinter import Tk, Entry root = Tk() root.title(&amp;quot;Probando el widget Entry&amp;quot;) root.resizable(width=True, height=True) root.</description>
    </item>
    
    <item>
      <title>46. Interfaces gráficas V</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb46-interfaces-graficas-v/</link>
      <pubDate>Thu, 23 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb46-interfaces-graficas-v/</guid>
      <description>Vídeo   Notas personales En esta lección, presentaremos dos widgets nuevos: Text y Button. El primero de ellos nos permite introducir un texto de extensión considerable en un cuadro, mientras que el segundo simplemente se trata de la clase asociada a los botones que habitualmente pulsamos en cualquier aplicación.
Retomemos el último ejemplo de la lección anterior:
from tkinter import Tk, Frame, Entry, Label root = Tk() root.title(&amp;quot;Probando el widget Entry&amp;quot;) root.</description>
    </item>
    
    <item>
      <title>47. Interfaces gráficas VI</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb47-interfaces-graficas-vi/</link>
      <pubDate>Thu, 23 May 2019 00:00:02 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb47-interfaces-graficas-vi/</guid>
      <description>Vídeo   Notas personales A partir de esta lección, utilizando los conocimientos adquiridos a lo largo de todo el curso, empezaremos un nuevo proyecto: la creación de una calculadora. Comencemos elaborando su interfaz gráfica:
from tkinter import Button, Entry, Frame, Tk # Raíz raiz = Tk() raiz.title(&amp;quot;Calculadora&amp;quot;) raiz.iconbitmap(&amp;quot;icon.ico&amp;quot;) # Frame frame = Frame(raiz) frame.pack() # Pantalla pantalla = Entry(frame) pantalla.grid(row=1, column=1, padx=10, pady=10, columnspan=4) pantalla.config(background=&amp;quot;black&amp;quot;, fg=&amp;quot;#03f943&amp;quot;, justify=&amp;quot;right&amp;quot;) # Fila 1 de botones boton7 = Button(frame, text=&amp;quot;7&amp;quot;, width=3) boton7.</description>
    </item>
    
    <item>
      <title>48. Interfaces gráficas VII</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb48-interfaces-graficas-vii/</link>
      <pubDate>Fri, 24 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb48-interfaces-graficas-vii/</guid>
      <description>Vídeo   Notas personales Una vez elaborada la interfaz gráfica de la calculadora, en esta lección abordaremos cómo programar parte de la funcionalidad de la misma. Para empezar, nuestro objetivo será conseguir que al pulsar los diferentes botones numéricos aparezcan sus valores asociados en la pantalla.
Empecemos creando una variable para almacenar una cadena de texto y asociémosla a la pantalla:
numero_pantalla = StringVar() pantalla = Entry(frame, textvariable=numero_pantalla)  A continuación, creemos una función que, por ejemplo, escriba el número 4 en pantalla:</description>
    </item>
    
    <item>
      <title>49. Interfaces gráficas VIII</title>
      <link>https://imalexissaez.github.io/courses/python-basic/pb49-interfaces-graficas-viii/</link>
      <pubDate>Sat, 25 May 2019 00:00:01 +0100</pubDate>
      
      <guid>https://imalexissaez.github.io/courses/python-basic/pb49-interfaces-graficas-viii/</guid>
      <description>Vídeo   Notas personales En esta lección, nuestro objetivo será conseguir que la calculadora que estamos generando sea capaz de sumar valores numéricos enteros.
Empecemos declarando una variable global, que será accesible desde todos las funciones del programa, denominada operacion y que almacenará la operación aritmética que desea el usuario llevar a cabo. Además, la utilizaremos para conseguir que la pantalla vuelva a su estado inicial a través del uso de bloques condicionales.</description>
    </item>
    
  </channel>
</rss>