<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.3.1">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Alexis Sáez">

  
  
  
    
  
  <meta name="description" content="1. Introducción a la especialización La dificultad de la presente especialización está catalogada como de nivel intermedio, ya que requiere que poseamos cierta familiaridad con algunos conceptos de programación (en Python fundamentalmente) y estadística. No obstante, siempre podemos optar por complementar los cinco cursos con los materiales necesarios que nos permitan seguir el ritmo de las explicaciones (documentación, tutoriales, libros&hellip;).
Python ha sido el lenguaje de programación escogido porque:">

  
  <link rel="alternate" hreflang="en-us" href="https://imalexissaez.github.io/courses/applied-data-science-with-python/curso1-modulo1/">

  


  

  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    

    

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:400,400italic,700|Roboto+Mono">
  

  
  
  
  <link rel="stylesheet" href="/css/academic.min.a9a796b4dba28c78fc94d2550173437e.css">

  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-88993800-1', 'auto');
      
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://imalexissaez.github.io/courses/applied-data-science-with-python/curso1-modulo1/">

  
  
  
  
    
  
  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@imalexissaez">
  <meta property="twitter:creator" content="@imalexissaez">
  
  <meta property="og:site_name" content="Infinitos Contrastes">
  <meta property="og:url" content="https://imalexissaez.github.io/courses/applied-data-science-with-python/curso1-modulo1/">
  <meta property="og:title" content="Módulo 1 | Infinitos Contrastes">
  <meta property="og:description" content="1. Introducción a la especialización La dificultad de la presente especialización está catalogada como de nivel intermedio, ya que requiere que poseamos cierta familiaridad con algunos conceptos de programación (en Python fundamentalmente) y estadística. No obstante, siempre podemos optar por complementar los cinco cursos con los materiales necesarios que nos permitan seguir el ritmo de las explicaciones (documentación, tutoriales, libros&hellip;).
Python ha sido el lenguaje de programación escogido porque:"><meta property="og:image" content="https://imalexissaez.github.io/img/sharing.jpg">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-05-28T00:00:01&#43;01:00">
  
  <meta property="article:modified_time" content="2019-05-28T00:00:01&#43;01:00">
  

  


  





  <title>Módulo 1 | Infinitos Contrastes</title>

</head>


<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Buscar</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Buscar..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Infinitos Contrastes</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Barra de navegación">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Proyectos</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Artículos</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Acerca de</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contacto</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  

<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      





<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" id="search-query" placeholder="Buscar..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/applied-data-science-with-python/">Presentación</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/applied-data-science-with-python/curso1-modulo1/">Curso 1</a>
    <ul class="nav docs-sidenav">
      
      <li class="active">
        <a href="/courses/applied-data-science-with-python/curso1-modulo1/">Módulo 1</a>
      </li>
      
      <li >
        <a href="/courses/applied-data-science-with-python/curso1-modulo2/">Módulo 2</a>
      </li>
      
    </ul>
    

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">En esta página</a></li>
      </ul>

      <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#section-1">1. Introducción a la especialización</a></li>
<li><a href="#section-2">2. Ciencia de datos</a></li>
<li><a href="#section-3">3. Uso de Jupyter en Coursera</a></li>
<li><a href="#section-4">4. Funciones en Python</a></li>
<li><a href="#section-5">5. Tipos y secuencias en Python</a>
<ul>
<li><a href="#section-5-1">5.1. La función type</a></li>
<li><a href="#section-5-2">5.2. Tuplas y listas</a></li>
<li><a href="#section-5-3">5.3. Diccionarios</a></li>
</ul></li>
<li><a href="#section-6">6. Cadenas de texto</a></li>
<li><a href="#section-7">7. Lectura de archivos CSV</a></li>
<li><a href="#section-8">8. Fechas y horas en Python</a></li>
<li><a href="#section-9">9. Python avanzado: objetos y map()</a>
<ul>
<li><a href="#section-9-1">9.1 Objetos</a></li>
<li><a href="#section-9-2">9.2 map()</a></li>
</ul></li>
<li><a href="#section-10">10. Python avanzado: lambdas y comprensiones de listas</a>
<ul>
<li><a href="#section-10-1">10.1 Lambdas</a></li>
<li><a href="#section-10-2">10.2 Comprensiones de listas</a></li>
</ul></li>
<li><a href="#section-11">11. La librería NumPy</a>
<ul>
<li><a href="#section-11-1">11.1 Creando arrays</a></li>
<li><a href="#section-11-2">11.2 Combinando arrays</a></li>
<li><a href="#section-11-3">11.3 Operaciones</a></li>
<li><a href="#section-11-4">11.4 Funciones matemáticas</a></li>
<li><a href="#section-11-5">11.5 Extracción de elementos (indexing &amp; slicing)</a></li>
<li><a href="#section-11-6">11.6 Copiando datos</a></li>
<li><a href="#section-11-7">11.7 Iterando sobre arrays</a></li>
</ul></li>
<li><a href="#section-12">12. Cuestionario</a></li>
</ul></li>
</ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article" itemscope itemtype="http://schema.org/Article">

        <div class="docs-article-container">
          <h1 itemprop="name">Módulo 1</h1>

          <div class="article-style" itemprop="articleBody">
            

<h2 id="section-1">1. Introducción a la especialización</h2>

<p>La dificultad de la presente <a href="https://www.coursera.org/specializations/data-science-python" target="_blank">especialización</a> está catalogada como de nivel intermedio, ya que requiere que poseamos cierta familiaridad con algunos conceptos de programación (en <em>Python</em> fundamentalmente) y estadística. No obstante, siempre podemos optar por complementar los cinco cursos con los materiales necesarios que nos permitan seguir el ritmo de las explicaciones (documentación, tutoriales, libros&hellip;).</p>

<p><em>Python</em> ha sido el lenguaje de programación escogido porque:</p>

<ul>
<li>es fácil de aprender, destacando por la gran legibilidad de su código;</li>
<li>cuenta con cientos de librerías disponibles para desarrollar las tareas más diversas; y</li>
<li>posee potentes módulos para trabajar en las tareas propias de la <em>Ciencia de Datos</em> (el ecosistema <em>SciPy</em>).</li>
</ul>

<p>El primer curso de la especialización, <a href="https://www.coursera.org/learn/python-data-analysis" target="_blank">Introduction to Data Science in Python</a>, está compuesto por los siguientes cuatro módulos:</p>

<ol>
<li>Prerrequisitos de <em>Python</em>.</li>
<li>La librería <em>Pandas</em>.</li>
<li>Consultas (&rdquo;<em>querying</em>&rdquo;) y manipulaciones avanzadas con <em>Pandas</em>.</li>
<li>Análisis estadísticos básicos con <em>NumPy</em> y <em>SciPy</em>.</li>
</ol>

<h2 id="section-2">2. Ciencia de datos</h2>

<p>La popularidad de la <em>Ciencia de Datos</em> ha crecido de manera exponencial, hecho que podemos confirmar experimentalmente nosotros mismos si acudimos a la web de <em>Google Trends</em> y buscamos el término &ldquo;<em>data science</em>&rdquo;. Este interés queda justificado por la actual era de la información en la que vivimos, con compañías que utilizan de manera intensiva las diversas teorías de esta disciplina, como son <em>Google</em>, <em>Facebook</em>, <em>Netflix</em>&hellip;</p>

<p>La <em>Ciencia de Datos</em> se describe habitualmente, de manera gráfica, mediante el <a href="https://static1.squarespace.com/static/5150aec6e4b0e340ec52710a/t/51525c33e4b0b3e0d10f77ab/1364352052403/Data_Science_VD.png?format=750w" target="_blank">diagrama de Venn</a> de <em>Drew Conway</em>. No obstante, conceptos como &ldquo;escepticismo&rdquo;, &ldquo;experimentación&rdquo;, &ldquo;simulación&rdquo; o &ldquo;replicación&rdquo;, entre otros, también tienen cabida en esta disciplina. En esta misma línea, es recomendable la lectura del artículo &ldquo;<em>50 years of Data Science</em>&rdquo; (<a href="http://courses.csail.mit.edu/18.337/2015/docs/50YearsDataScience.pdf" target="_blank">enlace</a>), de la mano de <em>David Donoho</em>, y en el cual figuran las siguientes seis etapas que componen un proyecto de <em>Ciencia de Datos</em>:</p>

<ol>
<li>Exploración y preparación de los datos.</li>
<li>Representación y transformación de los datos.</li>
<li>Cálculos utilizando los datos.</li>
<li>Modelización de los datos.</li>
<li>Visualización y presentación de los datos.</li>
<li>&ldquo;Ciencia&rdquo; a través de la <em>Ciencia de Datos</em>.</li>
</ol>

<h2 id="section-3">3. Uso de Jupyter en Coursera</h2>

<p>Personalmente, como la especialización la seguiré en modo &ldquo;<em>Audit</em>&rdquo;, mi objetivo es realizar las tareas, los ejercicios e incluso los cuestionarios localmente, en lugar de a través de las herramientas que ofrece <em>Coursera</em> en la propia plataforma. Para ello, con miras a tener disponible el acceso a los distintos <em>notebooks</em> de <em>Jupyter</em>, he instalado en mi ordenador la última versión de <em>Anaconda</em> (<a href="https://www.anaconda.com/distribution/#download-section" target="_blank">enlace</a>).</p>

<h2 id="section-4">4. Funciones en Python</h2>

<p>Familiaricémonos un poco con los <em>notebooks</em> de <em>Python</em>.</p>

<pre><code class="language-python">x = 1
y = 2
x + y
</code></pre>

<pre><code>3
</code></pre>

<p>Los objetos declarados en una celda, permanecen disponibles para que trabajemos con ellos posteriormente como deseemos.</p>

<pre><code class="language-python">x
</code></pre>

<pre><code>1
</code></pre>

<p>Refactoricemos el anterior código en una función que sume dos números:</p>

<pre><code class="language-python">def sumar_numeros(x, y):
    return x + y

sumar_numeros(1, 2)
</code></pre>

<pre><code>3
</code></pre>

<p><strong>Ejercicio</strong>: modifica la anterior función para que acepte tres parámetros, en lugar de dos, y devuelva la suma de todos ellos.</p>

<pre><code class="language-python">def sumar_numeros(x, y, z):
    return x + y + z

sumar_numeros(1, 2, 3)
</code></pre>

<pre><code>6
</code></pre>

<p>Así definida, la función <code>sumar_numeros()</code> pierde la funcionalidad de sumar únicamente dos números, ya que <em>Python</em> arrojaría un error si solo le pasamos el valor de dos argumentos. Podemos solventar esta situación si el tercer parámetro declarado, <code>z</code>, queda como opcional.</p>

<p><em>Nota</em>: los parámetros opcionales de una función figuran siempre los últimos en la declaración de esta.</p>

<pre><code class="language-python">def sumar_numeros(x, y, z=None):
    if z == None:
        return x + y
    else:
        return x + y + z
    
sumar_numeros(1, 2)
</code></pre>

<pre><code>3
</code></pre>

<pre><code class="language-python">sumar_numeros(1, 2, 3)
</code></pre>

<pre><code>6
</code></pre>

<p>Para imprimir múltiples valores, como resultado de una celda en un <em>notebook</em> de <em>Jupyter</em>, podemos recurrir a la función <code>print()</code>.</p>

<pre><code class="language-python">print(sumar_numeros(2, 3))
print(sumar_numeros(2, 3, 4))
</code></pre>

<pre><code>5
9
</code></pre>

<p>Podemos asignar a variables los valores que una función devuelve.</p>

<pre><code class="language-python">def sumar_numeros(x, y, z=None, flag=False):
    if flag:
        print(&quot;El valor de flag es verdadero.&quot;)
    if z == None:
        return x + y
    else:
        return x + y + z
</code></pre>

<pre><code class="language-python">a = sumar_numeros(1, 2)
print(a)
</code></pre>

<pre><code>3
</code></pre>

<pre><code class="language-python">b = sumar_numeros(1, 2, 3, True)
print(b)
</code></pre>

<pre><code>El valor de flag es verdadero.
6
</code></pre>

<p>En ocasiones, puede resultarnos útil que, en la llamada a la función, aparezca el nombre de algunos de sus parámetros (o de todos ellos) junto con el valor asignado, puesto que aporta bastante legibilidad.</p>

<pre><code class="language-python">c = sumar_numeros(x=1, y=2, z=3, flag=True)
print(c)
</code></pre>

<pre><code>El valor de flag es verdadero.
6
</code></pre>

<p><strong>Ejercicio</strong>: reescribe la siguiente función para que funcione de manera correcta. Esta función debería sumar dos números si el valor del parámetro <code>kind</code> es <code>&quot;add&quot;</code> o si este no se le suministra. En caso contrario, debe restar al primer número el segundo.</p>

<pre><code class="language-python">def do_math(?, ?, ?):
  if (kind=='add'):
    return a+b
  else:
    return a-b

do_math(1, 2)
</code></pre>

<pre><code class="language-python">def do_math(a, b, kind=&quot;add&quot;):
    if kind == &quot;add&quot;:
        return a + b
    else:
        return a - b

do_math(1, 2)
</code></pre>

<pre><code>3
</code></pre>

<h2 id="section-5">5. Tipos y secuencias en Python</h2>

<h3 id="section-5-1">5.1. La función type</h3>

<p>Con la función <code>type()</code> accedemos al tipo de un objeto:</p>

<pre><code class="language-python">type(&quot;Esto es una cadena de texto.&quot;)
</code></pre>

<pre><code>str
</code></pre>

<pre><code class="language-python">type(None)
</code></pre>

<pre><code>NoneType
</code></pre>

<pre><code class="language-python">type(10)
</code></pre>

<pre><code>int
</code></pre>

<pre><code class="language-python">type(3.141592)
</code></pre>

<pre><code>float
</code></pre>

<pre><code class="language-python">type(sumar_numeros)
</code></pre>

<pre><code>function
</code></pre>

<p>Analicemos, a continuación, los tres tipos básicos de colecciones que <em>Python</em> posee: tuplas, listas y diccionarios.</p>

<h3 id="section-5-2">5.2. Tuplas y listas</h3>

<p>Por lo que respecta a las tuplas, son objetos inmutables que escribimos entre paréntesis (aunque el uso de estos es opcional si suministramos una serie de objetos separados por comas).</p>

<pre><code class="language-python">x = (1, &quot;a&quot;, True, 3.14)
type(x)
</code></pre>

<pre><code>tuple
</code></pre>

<pre><code class="language-python">x = 1, 'a', True, 3.14
type(x)
</code></pre>

<pre><code>tuple
</code></pre>

<p><em>Nota</em>: a la hora de declarar cadenas de texto, es indiferente utilizar comillas simples <code>'</code> o dobles <code>&quot;</code>.</p>

<p>Las listas, a diferencia de las tuplas, son mutables, es decir, está permitido modificar el valor de sus elementos, ampliarlas, reducirlas, etc. Para generar una, utilizamos los corchetes.</p>

<pre><code class="language-python">x = [1, &quot;a&quot;, True, 3.14]
type(x)
</code></pre>

<pre><code>list
</code></pre>

<p>Podemos añadir elementos a la anterior lista utilizando el método <code>append()</code>.</p>

<pre><code class="language-python">x.append(&quot;b&quot;)
x.append(1.0)
print(x)
</code></pre>

<pre><code>[1, 'a', True, 3.14, 'b', 1.0]
</code></pre>

<p>Tanto las listas como las tuplas son objetos iterables que podemos recorrer, por ejemplo, utilizando bucles.</p>

<pre><code class="language-python">tupla = (1, &quot;a&quot;, 3.14, True)

for t in tupla:
    print(t)
</code></pre>

<pre><code>1
a
3.14
True
</code></pre>

<pre><code class="language-python">lista = [2, 2.0, False, &quot;b&quot;]

for l in lista:
    print(l)
</code></pre>

<pre><code>2
2.0
False
b
</code></pre>

<p>Por otro lado, podemos acceder a los elementos de una tupla o lista a través de su índice, con el operador <code>[]</code> (que viene a ser un atajo para un método <code>get()</code> que posee un objeto de tipo <code>tuple</code> o <code>list</code>). Recordemos aquí que <em>Python</em> comienza a contar índices en cero y que cuando utilizamos números negativos, empezamos desde el último elemento de la colección hacia atrás.</p>

<pre><code class="language-python">tupla[0]
</code></pre>

<pre><code>1
</code></pre>

<pre><code class="language-python">lista[-1]
</code></pre>

<pre><code>'b'
</code></pre>

<p>A través de este operador, podemos reformular el anterior bucle de tipo <code>for</code> como uno de tipo <code>while</code>.</p>

<pre><code class="language-python">i = 0

while i != len(tupla):
    print(tupla[i])
    i += 1
</code></pre>

<pre><code>1
a
3.14
True
</code></pre>

<p>Podemos realizar &ldquo;operaciones matemáticas&rdquo; sobre ambos tipos de objetos. Por ejemplo,</p>

<ul>
<li><code>+</code> concatena.</li>
<li><code>*</code> repite.</li>
</ul>

<pre><code class="language-python">(1, 2) + (3, 4)
</code></pre>

<pre><code>(1, 2, 3, 4)
</code></pre>

<pre><code class="language-python">(1, 2) * 3
</code></pre>

<pre><code>(1, 2, 1, 2, 1, 2)
</code></pre>

<pre><code class="language-python">[3, False] + [&quot;a&quot;, 1.0]
</code></pre>

<pre><code>[3, False, 'a', 1.0]
</code></pre>

<pre><code class="language-python">[3.14] * 4
</code></pre>

<pre><code>[3.14, 3.14, 3.14, 3.14]
</code></pre>

<p>El operador <code>in</code> (y su contrapartida <code>not in</code>) es de suma utilidad, pues revisa si un elemento pertenece o no a una colección en concreto.</p>

<pre><code class="language-python">tupla
</code></pre>

<pre><code>(1, 'a', 3.14, True)
</code></pre>

<pre><code class="language-python">&quot;Hola&quot; in tupla
</code></pre>

<pre><code>False
</code></pre>

<pre><code class="language-python">&quot;a&quot; in tupla
</code></pre>

<pre><code>True
</code></pre>

<pre><code class="language-python">lista
</code></pre>

<pre><code>[2, 2.0, False, 'b']
</code></pre>

<pre><code class="language-python">2.71 not in lista
</code></pre>

<pre><code>True
</code></pre>

<pre><code class="language-python">&quot;b&quot; not in lista
</code></pre>

<pre><code>False
</code></pre>

<p>En <em>Python</em>, el operador <code>[]</code> puede devolver múltiples valores (técnica que habitualmente se conoce en inglés como <em>slicing</em>).</p>

<p>Como una cadena de texto, en <em>Python</em>, no es más que una lista de caracteres, veamos en acción esta técnica con un sencillo ejemplo.</p>

<pre><code class="language-python">texto = &quot;Esto es un texto de prueba.&quot;

print(texto[0])  # Primer carácter
print(texto[0:1])  # Primer carácter
print(texto[5:10])  # Desde el quinto hasta el décimo, sin llegar a él.
print(texto[4:])  # Desde el cuarto en adelante.
print(texto[:4])  # Desde el principio hasta el cuarto, sin llegar a él.
print(texto[0:15:2])  # Desde el principio hasta el 15, sin llegar a él y de dos en dos.
</code></pre>

<pre><code>E
E
es un
 es un texto de prueba.
Esto
Et su et
</code></pre>

<pre><code class="language-python">print(texto[-4:-2])
</code></pre>

<pre><code>eb
</code></pre>

<p>La técnica de <em>slicing</em> es básica a la hora de trabajar con matrices o tablas de datos, como veremos en futuras lecciones.</p>

<p><strong>Ejercicio</strong>: ¿cuál es la instrucción adecuada para extraer la palabra <code>Christopher</code> de la cadena de texto declarada en la variable <code>x</code>?</p>

<pre><code class="language-python">x = 'Dr. Christopher Brooks'

print(x[???])
</code></pre>

<pre><code class="language-python">x = 'Dr. Christopher Brooks'

print(x[4:15])
print(x[-18:-7])
</code></pre>

<pre><code>Christopher
Christopher
</code></pre>

<p>Como hemos dicho, las cadenas de texto no son más que listas de caracteres, por lo que aquellas operaciones que podemos realizar sobre estas últimas están también disponibles sobre las primeras.</p>

<pre><code class="language-python">nombre = &quot;Alexis&quot;
apellido = &quot;Sáez&quot;

print(nombre + &quot; &quot; + apellido)
print(nombre * 4)
print(&quot;exi&quot; in nombre)
</code></pre>

<pre><code>Alexis Sáez
AlexisAlexisAlexisAlexis
True
</code></pre>

<p>La función <code>split()</code> separa una cadena de texto en subcadenas:</p>

<pre><code class="language-python">nombre = &quot;Alexis Sáez&quot;.split(' ')[0]
apellido = &quot;Alexis Sáez&quot;.split(' ')[-1]
print(nombre)
print(apellido)
</code></pre>

<pre><code>Alexis
Sáez
</code></pre>

<p>Hemos de prestar atención a los tipos de los objetos cuando estamos realizando operaciones aritméticas con ellos, puesto que algunas combinaciones no están permitidas.</p>

<pre><code class="language-python">&quot;Alexis&quot; + 2
</code></pre>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-42-599373231bbc&gt; in &lt;module&gt;
----&gt; 1 &quot;Alexis&quot; + 2


TypeError: can only concatenate str (not &quot;int&quot;) to str
</code></pre>

<pre><code class="language-python">&quot;Alexis&quot; + str(2)
</code></pre>

<pre><code>'Alexis2'
</code></pre>

<h3 id="section-5-3">5.3. Diccionarios</h3>

<p>Examinemos, finalmente, los diccionarios, que son colecciones no ordenadas de elementos etiquetados, que siguen la sintaxis <code>key : value</code>. Si para las tuplas utilizamos paréntesis y para las lista corchetes, los diccionarios se generan a partir de llaves.</p>

<pre><code class="language-python">mails = {&quot;Alexis Sáez&quot;: &quot;ejemplo1@gmail.com&quot;,
         &quot;Ana Pérez&quot;: &quot;ejemplo2@gmail.com&quot;}
</code></pre>

<pre><code class="language-python">mails[&quot;Alexis Sáez&quot;]
</code></pre>

<pre><code>'ejemplo1@gmail.com'
</code></pre>

<p>Podemos añadir elementos a un diccionario utilizando la técnica de <code>key = value</code>.</p>

<pre><code class="language-python">mails[&quot;Juan Garcia&quot;] = &quot;ejemplo3@gmail.com&quot;
mails[&quot;Irene Martínez&quot;] = None
</code></pre>

<p>Los diccionarios son elementos iterables que podemos recorrer de diversas formas.</p>

<pre><code class="language-python">for nombre in mails:
    print(nombre)
</code></pre>

<pre><code>Alexis Sáez
Ana Pérez
Juan Garcia
Irene Martínez
</code></pre>

<pre><code class="language-python">for nombre in mails.keys():
    print(nombre)
</code></pre>

<pre><code>Alexis Sáez
Ana Pérez
Juan Garcia
Irene Martínez
</code></pre>

<pre><code class="language-python">for nombre in mails:
    print(mails[nombre])
</code></pre>

<pre><code>ejemplo1@gmail.com
ejemplo2@gmail.com
ejemplo3@gmail.com
None
</code></pre>

<pre><code class="language-python">for mail in mails.values():
    print(mail)
</code></pre>

<pre><code>ejemplo1@gmail.com
ejemplo2@gmail.com
ejemplo3@gmail.com
None
</code></pre>

<pre><code class="language-python">for nombre, mail in mails.items():  # Itera sobre keys y values a la vez.
    print(&quot;Nombre:&quot;, nombre, &quot;Mail:&quot;, mail)
</code></pre>

<pre><code>Nombre: Alexis Sáez Mail: ejemplo1@gmail.com
Nombre: Ana Pérez Mail: ejemplo2@gmail.com
Nombre: Juan Garcia Mail: ejemplo3@gmail.com
Nombre: Irene Martínez Mail: None
</code></pre>

<p>Este último ejemplo nos permite presentar una característica importante de <em>Python</em>: el <em>unpacking</em> (&ldquo;desempaquetado&rdquo;) de tuplas.</p>

<pre><code class="language-python">datos = (&quot;Alexis Sáez&quot;, &quot;ejemplo1@gmail.com&quot;)

nombre, mail = datos

print(nombre)
print(mail)
</code></pre>

<pre><code>Alexis Sáez
ejemplo1@gmail.com
</code></pre>

<p>Hemos de ser cautos, pues ha de coincidir la cantidad de variables con el total de elementos a &ldquo;desempacar&rdquo;.</p>

<pre><code class="language-python">nombre, mail, tfno = datos
</code></pre>

<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-53-472adc290c80&gt; in &lt;module&gt;
----&gt; 1 nombre, mail, tfno = datos


ValueError: not enough values to unpack (expected 3, got 2)
</code></pre>

<h2 id="section-6">6. Cadenas de texto</h2>

<p><em>Python</em> 3, por defecto, utiliza el estándar de codificación <a href="https://es.wikipedia.org/wiki/Unicode" target="_blank">Unicode</a>, por lo que no encontraremos dificultades a la hora de trabajar con diversos tipos de caracteres (más allá incluso de los existentes en el alfabeto latino).</p>

<p>Para evitar tener que envolver continuamente datos en la función <code>str()</code>, de cara a generar cadenas de texto, conviene que utilicemos la combinación de <em>marcadores</em> (conocidos como <em>placeholders</em> en inglés), <code>{}</code>, y el método <code>format()</code> asociado a los objetos de tipo <code>str</code>.</p>

<pre><code class="language-python">ventas = {&quot;precio&quot;: 3.14, 
          &quot;num_objetos&quot;: 5, 
          &quot;nombre&quot;: &quot;Alexis&quot;}

texto_factura = &quot;{} compró {} objetos a {} euros cada unidad, ascendiendo el total a {} euros.&quot;

print(texto_factura.format(ventas[&quot;nombre&quot;],
                           ventas[&quot;num_objetos&quot;],
                           ventas[&quot;precio&quot;],
                           ventas[&quot;precio&quot;] * ventas[&quot;num_objetos&quot;]))
</code></pre>

<pre><code>Alexis compró 5 objetos a 3.14 euros cada unidad, ascendiendo el total a 15.700000000000001 euros.
</code></pre>

<p>El método <code>format()</code> permite casi una miríada de posibilidades de configuración, tal como reza en la <a href="https://docs.python.org/3/library/string.html#format-string-syntax" target="_blank">página de documentación</a> asociada.</p>

<h2 id="section-7">7. Lectura de archivos CSV</h2>

<blockquote>
<p>Los archivos CSV (del inglés comma-separated values) son un tipo de documento en formato abierto sencillo para representar datos en forma de tabla, en las que las columnas se separan por comas (o punto y coma en donde la coma es el separador decimal: Chile, Perú, Argentina, España, Brasil&hellip;) y las filas por saltos de línea. (<a href="https://es.wikipedia.org/wiki/Valores_separados_por_comas" target="_blank">Fuente</a>)</p>
</blockquote>

<p>Para la lectura de este tipo de ficheros, utilizaremos la librería de <em>Python</em> <code>csv</code>, que hemos de importar para poder tener acceso a las funciones contenidas en ella.</p>

<pre><code class="language-python">import csv
</code></pre>

<p>A continuación, y para lo que resta de módulo, establezcamos la precisión de los números de tipo <code>float</code> a 2 en este <em>notebook</em>. Para ello, tecleamos</p>

<pre><code class="language-python">%precision 2
</code></pre>

<pre><code>'%.2f'
</code></pre>

<p>Este tipo de instrucciones, cuyo rango de aplicación únicamente comprende los <em>notebooks</em> de <em>Jupyter</em>, se conocen como <em>magic commands</em> y su documentación asociada la podemos encontrar siguiendo <a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank">este enlace</a>. Por otro lado, nos resultará sumamente útil la lectura de <a href="https://www.dataquest.io/blog/jupyter-notebook-tips-tricks-shortcuts/" target="_blank">este artículo</a> donde nos ofrecen consejos, atajos y orientaciones varias a la hora de trabajar con esta herramienta.</p>

<p>Procedamos, pues, a la lectura del archivo <code>mpg.csv</code> (ubicado en la carpeta <code>data</code>), conviertiéndolo en una lista de diccionarios. Junto con el conjunto de datos <em>Iris</em>, es uno de los ejemplos clásicos con los que se suele comenzar a trabajar, de manera práctica, en <em>Ciencia de Datos</em>.</p>

<pre><code class="language-python">with open(&quot;data/mpg.csv&quot;) as csvfile:
    mpg = list(csv.DictReader(csvfile))
</code></pre>

<pre><code class="language-python">mpg[:3]  # Primeros tres diccionarios (es decir, coches)
</code></pre>

<pre><code>[OrderedDict([('', '1'),
              ('manufacturer', 'audi'),
              ('model', 'a4'),
              ('displ', '1.8'),
              ('year', '1999'),
              ('cyl', '4'),
              ('trans', 'auto(l5)'),
              ('drv', 'f'),
              ('cty', '18'),
              ('hwy', '29'),
              ('fl', 'p'),
              ('class', 'compact')]),
 OrderedDict([('', '2'),
              ('manufacturer', 'audi'),
              ('model', 'a4'),
              ('displ', '1.8'),
              ('year', '1999'),
              ('cyl', '4'),
              ('trans', 'manual(m5)'),
              ('drv', 'f'),
              ('cty', '21'),
              ('hwy', '29'),
              ('fl', 'p'),
              ('class', 'compact')]),
 OrderedDict([('', '3'),
              ('manufacturer', 'audi'),
              ('model', 'a4'),
              ('displ', '2'),
              ('year', '2008'),
              ('cyl', '4'),
              ('trans', 'manual(m6)'),
              ('drv', 'f'),
              ('cty', '20'),
              ('hwy', '31'),
              ('fl', 'p'),
              ('class', 'compact')])]
</code></pre>

<p>El archivo <code>mpg.csv</code> contiene datos sobre el consumo de combustible de 234 coches, siendo las características registradas de estos las que se muestran a continuación:</p>

<ul>
<li><code>mpg</code>: millas por galón.</li>
<li><code>class</code>: clasificación del coche.</li>
<li><code>cty</code>: millas por galón en ciudad.</li>
<li><code>cyl</code>: número de cilindros del coche.</li>
<li><code>displ</code>: desplazamiento del motor del coche en litros.</li>
<li><code>drv</code>: tipo de tracción del coche (f = delantera, r = trasera, 4 = cuatro por cuatro).</li>
<li><code>fl</code>: tipo de combustible del coche (e = etanol E85, d = diesel, r = regular, p = premium, c = CNG).</li>
<li><code>hwy</code>: millas por galón en autopista.</li>
<li><code>manufacturer</code>: fabricante del coche.</li>
<li><code>model</code>: modelo del coche</li>
<li><code>trans</code>: tipo de transmisión del coche.</li>
<li><code>year</code>: año del modelo del coche.</li>
</ul>

<pre><code class="language-python">len(mpg)  # Total de coches
</code></pre>

<pre><code>234
</code></pre>

<p>Es decir, tenemos un diccionario por cada uno de los 234 coches existentes en el fichero <code>mpg.csv</code>.</p>

<p>Acto seguido, podemos acceder a las propiedades registradas a través del método <code>keys()</code> del diccionario.</p>

<pre><code class="language-python">mpg[0].keys()
</code></pre>

<pre><code>odict_keys(['', 'manufacturer', 'model', 'displ', 'year', 'cyl', 'trans', 'drv', 'cty', 'hwy', 'fl', 'class'])
</code></pre>

<p>Calculemos el consumo medio de millas por galón en ciudad de todos los coches.</p>

<p><em>Nota</em>: todos los valores son cadenas de texto, por lo que hemos de ser cautos a la hora de utilizar operaciones aritméticas entre ellos. En esta ocasión, la función <code>float()</code> resulta de gran utilidad.</p>

<pre><code class="language-python">consumo = 0

for coche in mpg:
    consumo += float(coche[&quot;cty&quot;])

media = consumo / len(mpg)

print(media)
</code></pre>

<pre><code>16.858974358974358
</code></pre>

<p>El anterior bloque de código puede ser expresado en una única línea gracias a las comprensiones de listas (<em>list comprehensions</em>):</p>

<pre><code class="language-python">sum(float(coche[&quot;cty&quot;]) for coche in mpg) / len(mpg)
</code></pre>

<pre><code>16.86
</code></pre>

<p>Para reforzar la anterior construcción, veamos el caso de la media de millas por galón en autopista, el código sería:</p>

<pre><code class="language-python">sum(float(coche[&quot;hwy&quot;]) for coche in mpg) / len(mpg)
</code></pre>

<pre><code>23.44
</code></pre>

<p>Dado un galón de combustible, se recorren más millas en autopista que en ciudad, conclusión lógica desde el punto de vista del sentido común.</p>

<p>A continuación, compliquemos un poco más las consultas que estamos realizando al conjunto de datos <code>mpg</code>. Busquemos ahora el consumo medio de millas por galón en ciudad, pero desagregado en función del número de cilindros que posee un coche.</p>

<p>En primer lugar, obtengamos un conjunto con los valores disponibles para el número de cilindros, para lo cual la función <code>set()</code> resulta de gran ayuda.</p>

<pre><code class="language-python">cilindros = set(coche[&quot;cyl&quot;] for coche in mpg)
cilindros
</code></pre>

<pre><code>{'4', '5', '6', '8'}
</code></pre>

<p>Es decir, tenemos coches en nuestro conjunto de datos con 4, 5, 6 u 8 cilindros.</p>

<p>Ahora, almacenemos en una lista las cuatro medias que nos interesan. Para cada valor del conjunto de cilindros, recorreremos el conjunto de diccionarios y, en caso de coincidir el valor de un coche con el de interés, procederemos a realizar los cálculos oportunos.</p>

<pre><code class="language-python">mpg_cty_cilindro = []

for cilindro in cilindros:  # Iteramos sobre los distintos números de cilindros
    suma_mpg = 0
    total_coches_cilindro = 0
    for coche in mpg:  # Iteramos sobre todos los diccionarios
        if coche['cyl'] == cilindro:  # Si el número de cilindros coincide
            suma_mpg += float(coche['cty'])  # suma mpg
            total_coches_cilindro += 1  # incrementa el contador
    mpg_cty_cilindro.append((cilindro, suma_mpg / total_coches_cilindro)) # añade la tupla ('cilindro', 'mpg medio')

mpg_cty_cilindro.sort(key=lambda x: x[0])  # ordena por cilindros de menor a mayor
mpg_cty_cilindro
</code></pre>

<pre><code>[('4', 21.01), ('5', 20.50), ('6', 16.22), ('8', 12.57)]
</code></pre>

<p>Hemos empleado una función <em>lambda</em> o <em>anónima</em>, que es un tipo especial de funciones que estudiaremos en una lección posterior.</p>

<p>A medida que el número de cilindros crece, las millas por galón en ciudad decrecen.</p>

<p>Estudiemos un ejemplo similar para reforzar las líneas de código vistas en el anterior: busquemos la media de millas por galón en autovía para las diferentes clases de coches.</p>

<pre><code class="language-python">clases_coches = set(coche['class'] for coche in mpg) 
clases_coches
</code></pre>

<pre><code>{'2seater', 'compact', 'midsize', 'minivan', 'pickup', 'subcompact', 'suv'}
</code></pre>

<pre><code class="language-python">mpg_hwy_clase = []

for clase in clases_coches: 
    suma_mpg = 0
    total_coches_clase = 0
    for coche in mpg: 
        if coche['class'] == clase: 
            suma_mpg += float(coche['hwy']) 
            total_coches_clase += 1 
    mpg_hwy_clase.append((clase, suma_mpg / total_coches_clase))

mpg_hwy_clase.sort(key=lambda x: x[1])
mpg_hwy_clase
</code></pre>

<pre><code>[('pickup', 16.88),
 ('suv', 18.13),
 ('minivan', 22.36),
 ('2seater', 24.80),
 ('midsize', 27.29),
 ('subcompact', 28.14),
 ('compact', 28.30)]
</code></pre>

<p>A primera vista, el proceso para llevar a cabo los análisis presentados es un tanto complejo y tedioso de realizar. Veremos, en el próximo módulo, que la librería <code>pandas</code> agilizará todos estos procedimientos.</p>

<h2 id="section-8">8. Fechas y horas en Python</h2>

<p>En ocasiones, a la hora de llevar a cabo de análisis de datos, hemos de trabajar con fechas y horas. Por ejemplo, si buscamos el período de mayor ventas durante una etapa determinada o la hora de mayor actividad, por parte de los usuarios, en un foro de Internet.</p>

<p>En <em>Python</em>, las librerías habituales para trabajar con fechas y horas son <code>datetime</code> y <code>time</code>.</p>

<pre><code class="language-python">import datetime as dt
import time as tm
</code></pre>

<p>La función <code>time()</code> devuelve el número de segundos transcurridos desde el uno de enero de 1970 (<em>Epoch</em>).</p>

<pre><code class="language-python">tm.time()
</code></pre>

<pre><code>1559035984.46
</code></pre>

<p>Obviamente, no resulta especialmente cómodo trabajar unidades de tiempo de esta manera. No obstante, si nos proporcionan datos codificados de esta forma, podemos convertirlos en fechas y horas más manejables utilizando la función <code>fromtimestamp()</code> del módulo <code>datetime</code>.</p>

<pre><code class="language-python">dtnow = dt.datetime.fromtimestamp(tm.time())
dtnow
</code></pre>

<pre><code>datetime.datetime(2019, 5, 28, 11, 33, 4, 627060)
</code></pre>

<p>Como podíamos sospechar, la variable generada, <code>dtnow</code>, posee atributos de gran utilidad a la hora de trabajar con fechas y horas.</p>

<pre><code class="language-python">dtnow.year, dtnow.month, dtnow.day, dtnow.hour, dtnow.minute, dtnow.second  # extrae año, mes, día... de una fecha
</code></pre>

<pre><code>(2019, 5, 28, 11, 33, 4)
</code></pre>

<p><em>Nota técnica</em>: cuando en <em>Python</em> separamos variables por una coma, aunque no estemos utilizando paréntesis, implícitamente estamos generando una tupla.</p>

<p>La función <code>timedelta()</code> nos posibilita realizar operaciones aritméticas y comparaciones entre fechas y horas.</p>

<pre><code class="language-python">delta = dt.timedelta(days = 100)  # crea una diferencia delta de 100 días
delta
</code></pre>

<pre><code>datetime.timedelta(days=100)
</code></pre>

<p>La anterior función mostrada se utiliza habitualmente para crear períodos de interés a la hora de estudiar conjuntos de datos. Por ejemplo:</p>

<pre><code class="language-python">today = dt.date.today()
</code></pre>

<pre><code class="language-python">today - delta
</code></pre>

<pre><code>datetime.date(2019, 2, 17)
</code></pre>

<p>Finalmente, la librería <code>datetime</code> nos permite fácilmente llevar a cabo comparaciones entre fechas y horas.</p>

<pre><code class="language-python">today &gt; today - delta  # comparación entre fechas
</code></pre>

<pre><code>True
</code></pre>

<h2 id="section-9">9. Python avanzado: objetos y map()</h2>

<h3 id="section-9-1">9.1 Objetos</h3>

<p>Aunque, a lo largo de la especialización, rara vez nos veremos en la tesitura de generar clases propias, refresquemos su creación en <em>Python</em> elaborando una que modelice personas:</p>

<pre><code class="language-python">class Persona:
    departamento = &quot;Departamento de Educación&quot;  # Variable que comparten todos los objetos instanciados de la clase
    
    def set_nombre(self, nombre):  # ejemplo de método
        self.nombre = nombre
    def set_localizacion(self, localizacion):
        self.localizacion = localizacion
</code></pre>

<p>Instanciemos la clase:</p>

<pre><code class="language-python">alexis = Persona()
alexis.set_nombre(&quot;Alexis Sáez&quot;)
alexis.set_localizacion(&quot;Ibi (Alicante, España)&quot;)

print(&quot;{} vive en {} y trabaja en el {}.&quot;.format(alexis.nombre, alexis.localizacion, alexis.departamento))
</code></pre>

<pre><code>Alexis Sáez vive en Ibi (Alicante, España) y trabaja en el Departamento de Educación.
</code></pre>

<h3 id="section-9-2">9.2 map()</h3>

<p>Acto seguido, supongamos que tenemos acceso a los precios para cuatro productos que ofrecen dos tiendas diferentes. Nuestro objetivo es averiguar a cuánto ascenderá el desembolso total, si buscamos adquirir dichos cuatro productos, de manera que paguemos la menor cantidad monetaria para cada uno de ellos. Dadas ambas listas de precios, dicho tipo de comparaciones elemento a elemento se pueden llevar a cabo a través de la función <code>map()</code>, que aplica una determinada función a una serie de objetos iterables.</p>

<pre><code class="language-python">tienda1 = [10.00, 11.00, 12.34, 2.34]
tienda2 = [9.00, 11.10, 12.34, 2.01]
precio_mas_barato = map(min, tienda1, tienda2)
precio_mas_barato  # lazy evaluation
</code></pre>

<pre><code>&lt;map at 0x1288ced92e8&gt;
</code></pre>

<p><em>Python</em>, de hecho, no calcula mínimo alguno cuando creamos la variable <code>precio_mas_barato</code>, sino que espera hasta el momento que procedemos a iterar sobre este objeto de tipo <code>map</code>. Esta manera de actuar se conoce como <em>lazy evaluation</em> y nos permite una gestión eficiente de la memoria.</p>

<pre><code class="language-python">for precio in precio_mas_barato:
    print(precio)
</code></pre>

<pre><code>9.0
11.0
12.34
2.01
</code></pre>

<pre><code class="language-python">desembolso = sum(list(map(min, tienda1, tienda2)))
desembolso
</code></pre>

<pre><code>34.35
</code></pre>

<p><strong>Ejercicio</strong>: dada la siguiente lista de profesores de la especialización, escribe una función y utilízala combinada con <code>map()</code> para extraer tanto el título de cada persona como su apellido (por ejemplo, <code>['Dr. Brooks', 'Dr. Collins-Thompson', …]</code>).</p>

<pre><code class="language-python">people = ['Dr. Christopher Brooks', 'Dr. Kevyn Collins-Thompson', 'Dr. VG Vinod Vydiswaran', 'Dr. Daniel Romero']

def split_title_and_name(person):
    return #Your answer here

list(map(#Your answer here))
</code></pre>

<pre><code class="language-python">people = ['Dr. Christopher Brooks', 
          'Dr. Kevyn Collins-Thompson', 
          'Dr. VG Vinod Vydiswaran', 
          'Dr. Daniel Romero']

def split_title_and_name(person):
    separated_name = person.split(&quot; &quot;)
    return &quot;{} {}&quot;.format(separated_name[0], separated_name[-1])

list(map(split_title_and_name, people))
</code></pre>

<pre><code>['Dr. Brooks', 'Dr. Collins-Thompson', 'Dr. Vydiswaran', 'Dr. Romero']
</code></pre>

<h2 id="section-10">10. Python avanzado: lambdas y comprensiones de listas</h2>

<h3 id="section-10-1">10.1 Lambdas</h3>

<p>La palabra clave <code>lambda</code> nos permite crear funciones anónimas en <em>Python</em> (conocidas comúnmente en este lenguaje de programación como <em>lambdas</em>). Suelen ser funciones cortas, que podemos escribir generalmente en una línea (una única expresión, sin valores para parámetros opciones ni una lógica compleja en su interior) y mediante la instrucción <code>lambda</code> no nos vemos en la necesidad de haber de crear una función con nombre para desempeñar cierta tarea concreta.</p>

<p>Veamos un ejemplo de una función <em>lambda</em> que toma tres parámetros y suma los primeros dos.</p>

<pre><code class="language-python">suma_dos = lambda a, b, c: a + b
</code></pre>

<pre><code class="language-python">suma_dos(1, 2, 3)
</code></pre>

<pre><code>3
</code></pre>

<pre><code class="language-python">suma_dos(3, 2, 1)
</code></pre>

<pre><code>5
</code></pre>

<p><strong>Ejercicio</strong>: convierte la siguiente función en una anónima o <em>lambda</em>:</p>

<pre><code class="language-python">people = ['Dr. Christopher Brooks', 'Dr. Kevyn Collins-Thompson', 'Dr. VG Vinod Vydiswaran', 'Dr. Daniel Romero']

def split_title_and_name(person):
    return person.split()[0] + ' ' + person.split()[-1]

#option 1
for person in people:
    print(split_title_and_name(person) == (lambda person:???))

#option 2
#list(map(split_title_and_name, people)) == list(map(???))

</code></pre>

<pre><code class="language-python">people = ['Dr. Christopher Brooks', 
          'Dr. Kevyn Collins-Thompson', 
          'Dr. VG Vinod Vydiswaran', 
          'Dr. Daniel Romero']

def split_title_and_name(person):
    return person.split()[0] + ' ' + person.split()[-1]

# Opción 1
for person in people:
    print(split_title_and_name(person) == (lambda p: p.split()[0] + ' ' + p.split()[-1])(person))

# Opción 2
list(map(split_title_and_name, people)) == list(map(lambda person: person.split()[0] + ' ' + person.split()[-1], people))
</code></pre>

<pre><code>True
True
True
True





True
</code></pre>

<h3 id="section-10-2">10.2 Comprensiones de listas</h3>

<p>A continuación, almacenemos en una lista los números pares menores que mil:</p>

<pre><code class="language-python">lista_pares = []

for i in range(1000):
    if i % 2 == 0:
        lista_pares.append(i)

print(lista_pares[:50])  # Primeros cincuenta pares
</code></pre>

<pre><code>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]
</code></pre>

<p>Mediante las comprensiones de listas podemos conseguir el mismo objetivo con un menor número de líneas de código, expresando el bucle y la estructura condicional de una forma mucho más compacta (que también tiende a ser más rápida y eficiente):</p>

<pre><code class="language-python">lista_pares = [i for i in range(1000) if i % 2 == 0]
print(lista_pares[:50])  # Primeros 50 pares
</code></pre>

<pre><code>[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98]
</code></pre>

<p><strong>Ejercicio</strong>: convierte la siguiente función en una comprensión de lista:</p>

<pre><code class="language-python">def times_tables():
    lst = []
    for i in range(10):
        for j in range (10):
            lst.append(i*j)
    return lst

times_tables() == [???]
</code></pre>

<pre><code class="language-python">def times_tables():
    lst = []
    for i in range(10):
        for j in range (10):
            lst.append(i*j)
    return lst

times_tables() == [i * j for i in range(10) for j in range(10)]
</code></pre>

<pre><code>True
</code></pre>

<p><strong>Ejercicio</strong>: muchas organizaciones poseen identificadores de usuario que están restringidas en cierta manera. Supón que trabajas para un proveedor de internet y dichos identificadores están formados por dos letras seguiidas de dos números (por ejemplo, <code>aa49</code>). Tu tarea en la empresa podría ser mantener un registro de la facturación para cada posible usuario.</p>

<p>Escribe una comprensión de lista que genere todos los posibles identificadores de usuario. Supón que las letras son únicamente minúsculas.</p>

<pre><code class="language-python">lowercase = 'abcdefghijklmnopqrstuvwxyz'
digits = '0123456789'

answer = [???]
correct_answer == answer
</code></pre>

<pre><code class="language-python">lowercase = 'abcdefghijklmnopqrstuvwxyz'
digits = '0123456789'

answer = [i + j + k + l for i in lowercase for j in lowercase for k in digits for l in digits]
print(answer[:50])  # Primeros 50 identificadores
</code></pre>

<pre><code>['aa00', 'aa01', 'aa02', 'aa03', 'aa04', 'aa05', 'aa06', 'aa07', 'aa08', 'aa09', 'aa10', 'aa11', 'aa12', 'aa13', 'aa14', 'aa15', 'aa16', 'aa17', 'aa18', 'aa19', 'aa20', 'aa21', 'aa22', 'aa23', 'aa24', 'aa25', 'aa26', 'aa27', 'aa28', 'aa29', 'aa30', 'aa31', 'aa32', 'aa33', 'aa34', 'aa35', 'aa36', 'aa37', 'aa38', 'aa39', 'aa40', 'aa41', 'aa42', 'aa43', 'aa44', 'aa45', 'aa46', 'aa47', 'aa48', 'aa49']
</code></pre>

<h2 id="section-11">11. La librería NumPy</h2>

<p>Adentrémonos, en este apartado, en los entresijos de la librería <em>NumPy</em>. Sobre este módulo se asienta el ecosistema que permite trabajar <em>Ciencia de Datos</em> en <em>Python</em>, ya que posibilita el cálculo con <em>arrays</em> y <em>matrices</em> de una manera eficiente en este lenguaje de programación.</p>

<pre><code class="language-python">import numpy as np
</code></pre>

<h3 id="section-11-1">11.1 Creando arrays</h3>

<p>A continuación, generemos nuestro primer <em>array</em> con <em>NumPy</em>. Para ello, podemos crear una lista y convertirla a dicha estructura:</p>

<pre><code class="language-python">mi_lista = [1, 2, 3]
x = np.array(mi_lista)
x
</code></pre>

<pre><code>array([1, 2, 3])
</code></pre>

<p>También podemos construir <em>arrays</em> pasando como argumento una lista a la función <code>array()</code>:</p>

<pre><code class="language-python">x = np.array([1, 2, 3])
x
</code></pre>

<pre><code>array([1, 2, 3])
</code></pre>

<p>De manera similar, generamos <em>arrays</em> multidimensionales a partir de una lista de listas como argumento de la función <code>array()</code>:</p>

<pre><code class="language-python">m = np.array([[1, 2, 3], [4, 5, 6]])
m
</code></pre>

<pre><code>array([[1, 2, 3],
       [4, 5, 6]])
</code></pre>

<p>El atributo <code>shape</code>, de un objeto de tipo <code>array</code> de <em>NumPy</em>, devuelve las dimensiones (filas y columnas) del <em>array</em> generado:</p>

<pre><code class="language-python">x.shape
</code></pre>

<pre><code>(3,)
</code></pre>

<pre><code class="language-python">m.shape
</code></pre>

<pre><code>(2, 3)
</code></pre>

<p>La función <code>reshape()</code> permite modificar las dimensiones de <em>array</em> determinado:</p>

<pre><code class="language-python">m.reshape(3, 2)
</code></pre>

<pre><code>array([[1, 2],
       [3, 4],
       [5, 6]])
</code></pre>

<p>La función <code>arange()</code> devuelve valores equiespaciados en un intervalo dado:</p>

<pre><code class="language-python">n = np.arange(0, 30, 2)  # empieza en 0, de 2 en 2, hasta 29
n
</code></pre>

<pre><code>array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28])
</code></pre>

<pre><code class="language-python">n = np.arange(1, 47, 5)
n
</code></pre>

<pre><code>array([ 1,  6, 11, 16, 21, 26, 31, 36, 41, 46])
</code></pre>

<p>En cambio, si dado un intervalo queremos generar en su interior una serie de puntos equiespaciados, la función a utilizar es <code>linspace()</code>:</p>

<pre><code class="language-python">o = np.linspace(0, 4, 9)  # devuelve 9 valores equiespaciados entre 0 y 4
o
</code></pre>

<pre><code>array([0. , 0.5, 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. ])
</code></pre>

<pre><code class="language-python">o.reshape(3, 3)
</code></pre>

<pre><code>array([[0. , 0.5, 1. ],
       [1.5, 2. , 2.5],
       [3. , 3.5, 4. ]])
</code></pre>

<p>Existen una serie de funciones especiales para generar <em>arrays</em> con una estructura particular:</p>

<ul>
<li><code>ones()</code>: <em>array</em> de unos.</li>
<li><code>zeros()</code>: <em>array</em> de ceros.</li>
<li><code>eye()</code>: matriz unidad.</li>
<li><code>diag()</code>: matriz diagonal a partir de un <em>array</em>.</li>
</ul>

<pre><code class="language-python">np.ones((4, 5))
</code></pre>

<pre><code>array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])
</code></pre>

<pre><code class="language-python">np.zeros((3, 4))
</code></pre>

<pre><code>array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])
</code></pre>

<pre><code class="language-python">np.eye(5)
</code></pre>

<pre><code>array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
</code></pre>

<pre><code class="language-python">np.diag(np.array([1, 2, 3, 4]))
</code></pre>

<pre><code>array([[1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4]])
</code></pre>

<p>El operador <code>*</code> o la función <code>repeat()</code> nos permiten repetir una lista, pero hay sutiles matices en su funcionamiento, como apreciamos acto seguido:</p>

<pre><code class="language-python">np.array([1, 2, 3] * 3)
</code></pre>

<pre><code>array([1, 2, 3, 1, 2, 3, 1, 2, 3])
</code></pre>

<pre><code class="language-python">np.repeat(np.array([1, 2, 3]), 3)
</code></pre>

<pre><code>array([1, 1, 1, 2, 2, 2, 3, 3, 3])
</code></pre>

<h3 id="section-11-2">11.2 Combinando arrays</h3>

<p>Por otro lado, podemos construir nuevos <em>arrays</em> combinando unos existentes.</p>

<pre><code class="language-python">p = np.ones([2, 3], int)
p
</code></pre>

<pre><code>array([[1, 1, 1],
       [1, 1, 1]])
</code></pre>

<p>Con la función <code>vstack()</code> apilamos arrays verticalmente (por filas):</p>

<pre><code class="language-python">np.vstack([p, 2*p])
</code></pre>

<pre><code>array([[1, 1, 1],
       [1, 1, 1],
       [2, 2, 2],
       [2, 2, 2]])
</code></pre>

<p>Mientras que la función <code>hstack()</code> hace lo propio horizontalmente (por columnas):</p>

<pre><code class="language-python">np.hstack([p, 2*p])
</code></pre>

<pre><code>array([[1, 1, 1, 2, 2, 2],
       [1, 1, 1, 2, 2, 2]])
</code></pre>

<h3 id="section-11-3">11.3 Operaciones</h3>

<p>Los operadores aritméticos realizan las opciones elemento a elemento:</p>

<pre><code class="language-python">x = np.array([1, 2, 3])
y = np.array([4, 5, 6])
</code></pre>

<pre><code class="language-python">x + y
</code></pre>

<pre><code>array([5, 7, 9])
</code></pre>

<pre><code class="language-python">x - y
</code></pre>

<pre><code>array([-3, -3, -3])
</code></pre>

<pre><code class="language-python">x * y
</code></pre>

<pre><code>array([ 4, 10, 18])
</code></pre>

<pre><code class="language-python">x / y
</code></pre>

<pre><code>array([0.25, 0.4 , 0.5 ])
</code></pre>

<pre><code class="language-python">x ** 2
</code></pre>

<pre><code>array([1, 4, 9], dtype=int32)
</code></pre>

<p>Para calcular el producto escalar, hemos de utilizar la función <code>dot()</code>:</p>

<pre><code class="language-python">x.dot(y)
</code></pre>

<pre><code>32
</code></pre>

<p>El atributo <code>.T</code> realiza la transposición de un <em>array</em></p>

<pre><code class="language-python">z = np.array([y, y**2])
z
</code></pre>

<pre><code>array([[ 4,  5,  6],
       [16, 25, 36]])
</code></pre>

<pre><code class="language-python">z.shape
</code></pre>

<pre><code>(2, 3)
</code></pre>

<pre><code class="language-python">z.T
</code></pre>

<pre><code>array([[ 4, 16],
       [ 5, 25],
       [ 6, 36]])
</code></pre>

<pre><code class="language-python">z.T.shape
</code></pre>

<pre><code>(3, 2)
</code></pre>

<p>Finalmente, el atributo <code>.dtype</code> nos indica el tipo de variable en que está almacenado un <em>array</em>, que podemos modificar mediante la función <code>astype()</code>.</p>

<pre><code class="language-python">z.dtype
</code></pre>

<pre><code>dtype('int32')
</code></pre>

<pre><code class="language-python">z = z.astype(&quot;f&quot;)
z.dtype
</code></pre>

<pre><code>dtype('float32')
</code></pre>

<h3 id="section-11-4">11.4 Funciones matemáticas</h3>

<p>La librería <em>NumPy</em> incorpora de base algunas conocidas funciones matemáticas.</p>

<pre><code class="language-python">a = np.array([-4, -2, 1, 3, 5])
a
</code></pre>

<pre><code>array([-4, -2,  1,  3,  5])
</code></pre>

<pre><code class="language-python">a.sum()
</code></pre>

<pre><code>3
</code></pre>

<pre><code class="language-python">a.max()
</code></pre>

<pre><code>5
</code></pre>

<pre><code class="language-python">a.argmax()  # posición del máximo
</code></pre>

<pre><code>4
</code></pre>

<pre><code class="language-python">a.min()
</code></pre>

<pre><code>-4
</code></pre>

<pre><code class="language-python">a.argmin()  # posición del mínimo
</code></pre>

<pre><code>0
</code></pre>

<pre><code class="language-python">a.mean()
</code></pre>

<pre><code>0.6
</code></pre>

<pre><code class="language-python">a.std()
</code></pre>

<pre><code>3.2619012860600183
</code></pre>

<h3 id="section-11-5">11.5 Extracción de elementos (indexing &amp; slicing)</h3>

<p>A continuación, veamos qué posibilidades nos ofrece <em>NumPy</em> de cara a la extracción de elementos de un <em>array</em>.</p>

<pre><code class="language-python">s = np.arange(13) ** 2
s
</code></pre>

<pre><code>array([  0,   1,   4,   9,  16,  25,  36,  49,  64,  81, 100, 121, 144],
      dtype=int32)
</code></pre>

<p>Con el operador <code>[]</code> accedemos, al igual que cuando utilizamos otro tipo de colecciones, al elemento ubicado en un índice concreto.</p>

<pre><code class="language-python">s[0], s[4], s[-1]
</code></pre>

<pre><code>(0, 16, 144)
</code></pre>

<p>Mediante el operador <code>:</code> extraemos múltiples elementos de un <em>array</em> de manera simultánea, tal y como estamos acostumbrados a utilizar dicho operador.</p>

<pre><code class="language-python">s[0:4]
</code></pre>

<pre><code>array([0, 1, 4, 9], dtype=int32)
</code></pre>

<pre><code class="language-python">s[:3]
</code></pre>

<pre><code>array([0, 1, 4], dtype=int32)
</code></pre>

<pre><code class="language-python">s[2:8:2]
</code></pre>

<pre><code>array([ 4, 16, 36], dtype=int32)
</code></pre>

<pre><code class="language-python">s[-5::-2]
</code></pre>

<pre><code>array([64, 36, 16,  4,  0], dtype=int32)
</code></pre>

<p>Podemos extender el uso de esta notación a <em>arrays</em> multidimensionales.</p>

<pre><code class="language-python">r = np.arange(36)
r.resize((6, 6))
r
</code></pre>

<pre><code>array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
</code></pre>

<pre><code class="language-python">r[2, 2]
</code></pre>

<pre><code>14
</code></pre>

<pre><code class="language-python">r[3, 3:6]
</code></pre>

<pre><code>array([21, 22, 23])
</code></pre>

<pre><code class="language-python">r[:2, :-1]
</code></pre>

<pre><code>array([[ 0,  1,  2,  3,  4],
       [ 6,  7,  8,  9, 10]])
</code></pre>

<pre><code class="language-python">r[-1, ::2]
</code></pre>

<pre><code>array([30, 32, 34])
</code></pre>

<p>También podemos realizar operaciones de filtrado utilizando condiciones lógicas (en este punto nos puede interesar ver también la función <code>where()</code>).</p>

<pre><code class="language-python">r[r &gt; 30]
</code></pre>

<pre><code>array([31, 32, 33, 34, 35])
</code></pre>

<pre><code class="language-python">r[r &gt; 30] = 30
r
</code></pre>

<pre><code>array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 30, 30, 30, 30, 30]])
</code></pre>

<h3 id="section-11-6">11.6 Copiando datos</h3>

<p>Hemos de ser cautos a la hora de copiar y modificar <em>arrays</em> en <em>NumPy</em>.</p>

<pre><code class="language-python">r2 = r[:3, :3]
r2
</code></pre>

<pre><code>array([[ 0,  1,  2],
       [ 6,  7,  8],
       [12, 13, 14]])
</code></pre>

<pre><code class="language-python">r2[:] = 0
r2
</code></pre>

<pre><code>array([[0, 0, 0],
       [0, 0, 0],
       [0, 0, 0]])
</code></pre>

<p>¡Pero <code>r</code> también ha cambiado!</p>

<pre><code class="language-python">r
</code></pre>

<pre><code>array([[ 0,  0,  0,  3,  4,  5],
       [ 0,  0,  0,  9, 10, 11],
       [ 0,  0,  0, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 30, 30, 30, 30, 30]])
</code></pre>

<p>Para evitar este comportamiento, conviene que utilicemos la función <code>copy()</code>.</p>

<pre><code class="language-python">r_copy = r.copy()
r_copy
</code></pre>

<pre><code>array([[ 0,  0,  0,  3,  4,  5],
       [ 0,  0,  0,  9, 10, 11],
       [ 0,  0,  0, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 30, 30, 30, 30, 30]])
</code></pre>

<pre><code class="language-python">r_copy[:] = 10
r_copy
</code></pre>

<pre><code>array([[10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10]])
</code></pre>

<p>No obstante, ahora <code>r</code> no ha sido modificado por las operaciones realizadas sobre <code>r_copy</code>.</p>

<pre><code class="language-python">r
</code></pre>

<pre><code>array([[ 0,  0,  0,  3,  4,  5],
       [ 0,  0,  0,  9, 10, 11],
       [ 0,  0,  0, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 30, 30, 30, 30, 30]])
</code></pre>

<p><strong>Ejercicio</strong>: Para el siguiente código, ¿qué opción recoge la salida correcta?</p>

<pre><code class="language-python">old = np.array([[1, 1, 1],
                [1, 1, 1]])

new = old
new[0, :2] = 0

print(old)
</code></pre>

<p>Opción 1:</p>

<pre><code>[[0 1 1]
 [1 1 1]]
</code></pre>

<p>Opción 2:</p>

<pre><code>[[1 1 1]
 [0 1 1]]
</code></pre>

<p>Opción 3:</p>

<pre><code>[[0 0 1]
 [1 1 1]]
</code></pre>

<p>Opción 4:</p>

<pre><code>[[1 1 1]
 [1 1 1]]
</code></pre>

<p>Como no hemos usado el método <code>copy()</code>, cualquier modificación sobre la variable <code>new</code> afecta a la variable <code>old</code>. Con la instrucción <code>new[0, :2] = 0</code> hacemos ceros los dos primeros elementos de la fila superior del <em>array</em> <code>new</code> y, por tanto, de <code>old</code> también. Así pues, la opción acertada es la 3. Comprobémoslo:</p>

<pre><code class="language-python">old = np.array([[1, 1, 1],
                [1, 1, 1]])

new = old
new[0, :2] = 0

print(old)
</code></pre>

<pre><code>[[0 0 1]
 [1 1 1]]
</code></pre>

<p><strong>Ejercicio</strong>: Para el siguiente código, ¿qué opción recoge la salida correcta?</p>

<pre><code class="language-python">old = np.array([[1, 1, 1],
                [1, 1, 1]])

new = old.copy()
new[:, 0] = 0

print(old)
</code></pre>

<p>Opción 1</p>

<pre><code>[[0 1 1]
 [0 1 1]]
</code></pre>

<p>Opción 2</p>

<pre><code>[[0 1 1]
 [1 1 1]]
</code></pre>

<p>Opción 3</p>

<pre><code>[[0 0 0]
 [1 1 1]]
</code></pre>

<p>Opción 4</p>

<pre><code>[[1 1 1]
 [1 1 1]]
</code></pre>

<p>En esta ocasión, al emplear la función <code>copy()</code>, los cambios sobre la variable <code>new</code> no afectan a la variable <code>old</code>. Por tanto, la opción correcta es la 4. Comprobémoslo:</p>

<pre><code class="language-python">old = np.array([[1, 1, 1],
                [1, 1, 1]])

new = old.copy()
new[:, 0] = 0

print(old)
</code></pre>

<pre><code>[[1 1 1]
 [1 1 1]]
</code></pre>

<h3 id="section-11-7">11.7 Iterando sobre arrays</h3>

<p>Finalmente, estudiemos cómo iterar sobre <em>arrays</em>:</p>

<pre><code class="language-python">matriz_aleatorios = np.random.randint(0, 10, (4,3))
matriz_aleatorios
</code></pre>

<pre><code>array([[8, 9, 8],
       [9, 5, 2],
       [2, 4, 6],
       [0, 0, 7]])
</code></pre>

<p>Por ejemplo, podemos iterar por filas de una manera sencilla:</p>

<pre><code class="language-python">for fila in matriz_aleatorios:
    print(fila)
</code></pre>

<pre><code>[8 9 8]
[9 5 2]
[2 4 6]
[0 0 7]
</code></pre>

<p>Asimismo, es posible iterar por el índice de la fila utilizando la función <code>len()</code>:</p>

<pre><code class="language-python">len(matriz_aleatorios)
</code></pre>

<pre><code>4
</code></pre>

<pre><code class="language-python">for i in range(len(matriz_aleatorios)):
    print(matriz_aleatorios[i])
</code></pre>

<pre><code>[8 9 8]
[9 5 2]
[2 4 6]
[0 0 7]
</code></pre>

<p>La función <code>enumerate()</code> nos posibilita combinar los dos anteriores métodos:</p>

<pre><code class="language-python">for i, fila in enumerate(matriz_aleatorios):
    print(&quot;La fila&quot;, i, &quot;es&quot;, fila)
</code></pre>

<pre><code>La fila 0 es [8 9 8]
La fila 1 es [9 5 2]
La fila 2 es [2 4 6]
La fila 3 es [0 0 7]
</code></pre>

<p>Para acabar, también podemos utiliza la función <code>zip()</code> para iterar sobre varios objetos iterables:</p>

<pre><code class="language-python">matriz_aleatorios_cuadrado = matriz_aleatorios ** 2
</code></pre>

<pre><code class="language-python">matriz_aleatorios_cuadrado
</code></pre>

<pre><code>array([[64, 81, 64],
       [81, 25,  4],
       [ 4, 16, 36],
       [ 0,  0, 49]], dtype=int32)
</code></pre>

<pre><code class="language-python">for i, j in zip(matriz_aleatorios, matriz_aleatorios_cuadrado):
    print(i, &quot;+&quot;, j, &quot;=&quot;, i + j)
</code></pre>

<pre><code>[8 9 8] + [64 81 64] = [72 90 72]
[9 5 2] + [81 25  4] = [90 30  6]
[2 4 6] + [ 4 16 36] = [ 6 20 42]
[0 0 7] + [ 0  0 49] = [ 0  0 56]
</code></pre>

<h2 id="section-12">12. Cuestionario</h2>

<p>Dado que estoy siguiendo la especialización en modo <em>Audit</em>, no tengo acceso a la posibilidad de verificar las respuestas que proporciono en los cuestionarios, así como sospecho que tampoco podré hacer lo propio con las prácticas de programación.</p>

<p>No obstante, comparto las respuestas que plantearía a las preguntas que proponen.</p>

<p><strong>Question 1</strong>: Python is an example of an</p>

<ul>
<li>(a) Interpreted language</li>
<li>(b) Declarative language</li>
<li>(c) Operating system language</li>
<li>(d) Data science language</li>
<li>(e) Low level language</li>
</ul>

<p><strong>Respuesta</strong>: (a)</p>

<p><strong>Question 2</strong>: Data Science is a</p>

<ul>
<li>(a) Branch of statistics</li>
<li>(b) Branch of computer science</li>
<li>(c) Branch of artificial intelligence</li>
<li>(d) Interdisciplinary, made up of all of the above</li>
</ul>

<p><strong>Respuesta</strong>: (d)</p>

<p><strong>Question 3</strong>: Data visualization is not a part of data science.</p>

<ul>
<li>(a) True</li>
<li>(b) False</li>
</ul>

<p><strong>Respuesta</strong>: (b)</p>

<p><strong>Question 4</strong>: Which bracketing style does Python use for tuples?</p>

<ul>
<li>(a) <code>{ }</code></li>
<li>(b) <code>( )</code></li>
<li>(c) <code>[ ]</code></li>
</ul>

<p><strong>Respuesta</strong>: (b)</p>

<p><strong>Question 5</strong>: In Python, strings are considered Mutable, and can be changed.</p>

<ul>
<li>(a) False</li>
<li>(b) True</li>
</ul>

<p><strong>Respuesta</strong>: (a)</p>

<p>Esta pregunta me ha resultado interesante, porque creo no se ha llegado a comentar nada al respecto en los vídeos teóricos. Veamos con un sencillo ejemplo que no podemos modificar parte de una cadena de caracteres:</p>

<pre><code class="language-python">texto = &quot;Esto es una prueba&quot;
texto[0]
</code></pre>

<pre><code>'E'
</code></pre>

<pre><code class="language-python">texto[0] = &quot;N&quot;
</code></pre>

<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-161-1659680a19da&gt; in &lt;module&gt;
----&gt; 1 texto[0] = &quot;N&quot;


TypeError: 'str' object does not support item assignment
</code></pre>

<p>No obstante, en cualquier momento podemos hacer que la variable <code>texto</code> apunte a una cadena de caracteres distinta a la dada:</p>

<pre><code class="language-python">texto = &quot;Segunda prueba&quot;
texto
</code></pre>

<pre><code>'Segunda prueba'
</code></pre>

<p><strong>Question 6</strong>: What is the result of the following code:</p>

<pre><code>['a', 'b', 'c'] + [1, 2, 3]
</code></pre>

<ul>
<li>(a) <code>['a', 'b', 'c', 1, 2, 3]</code></li>
<li>(b) <code>TypeError: Cannot convert list(int) to list(str)</code></li>
<li>(c) <code>['a1', 'b2', 'c3']</code></li>
<li>(d) <code>[['a', 'b', 'c'], [1, 2, 3]]</code></li>
</ul>

<p><strong>Respuesta</strong>: (a), el operador <code>+</code> concatena listas y en <em>Python</em> estas pueden contener elementos de diversos tipos.</p>

<pre><code class="language-python">['a', 'b', 'c'] + [1, 2, 3]
</code></pre>

<pre><code>['a', 'b', 'c', 1, 2, 3]
</code></pre>

<p><strong>Question 7</strong>: String slicing is</p>

<ul>
<li>(a) A way to make string mutable in python</li>
<li>(b) A way to reduce the size on disk of strings in python</li>
<li>(c) A way to make a substring of a string in python</li>
</ul>

<p><strong>Respuesta</strong>: (c)</p>

<p><strong>Question 8</strong>: When you create a lambda, what type is returned? E.g. <code>type(lambda x: x+1)</code> returns</p>

<ul>
<li>(a) <code>&lt;class 'function'&gt;</code></li>
<li>(b) <code>&lt;class 'type'&gt;</code></li>
<li>(c) <code>&lt;class 'int'&gt;</code></li>
<li>(d) <code>&lt;class 'lambda'&gt;</code></li>
</ul>

<p><strong>Respuesta</strong>: (a)</p>

<pre><code class="language-python">type(lambda x: x+1)
</code></pre>

<pre><code>function
</code></pre>

<p><strong>Question 9</strong>: The epoch refers to</p>

<ul>
<li>(a) January 1, year 0</li>
<li>(b) January 1, year 1970</li>
<li>(c) January 1, year 1980</li>
<li>(d) January 1, year 2000</li>
</ul>

<p><strong>Respuesta</strong>: (b)</p>

<p><strong>Question 10</strong>: This code, <code>[x**2 for x in range(10)]</code> , is an example of a</p>

<ul>
<li>(a) List comprehension</li>
<li>(b) Sequence comprehension</li>
<li>(c) Tuple comprehension</li>
<li>(d) List multiplication</li>
</ul>

<p><strong>Respuesta</strong>: (a)</p>

<p><strong>Question 11</strong>: Given a 6x6 NumPy array <code>r</code>, which of the following options would slice the shaded elements?</p>

<p><img src="/courses/applied-data-science-with-python/img/modulo1-quiz1-question11.png" alt="Matriz" /></p>

<ul>
<li>(a) <code>r[:, ::7]</code></li>
<li>(b) <code>r[0:6, ::-7]</code></li>
<li>(c) <code>r[::7]</code></li>
<li>(d) <code>r.reshape(36)[::7]</code></li>
</ul>

<p><strong>Respuesta</strong> (d)</p>

<pre><code class="language-python">r = np.arange(36).reshape(6, 6)
r
</code></pre>

<pre><code>array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11],
       [12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23],
       [24, 25, 26, 27, 28, 29],
       [30, 31, 32, 33, 34, 35]])
</code></pre>

<pre><code class="language-python">r.reshape(36)[::7]
</code></pre>

<pre><code>array([ 0,  7, 14, 21, 28, 35])
</code></pre>

<p><strong>Question 12</strong>: Given a 6x6 NumPy array r, which of the following options would slice the shaded elements?</p>

<p><img src="/courses/applied-data-science-with-python/img/modulo1-quiz1-question12.png" alt="Matriz" /></p>

<ul>
<li>(a) <code>r[::2, ::2]</code></li>
<li>(b) <code>r[2::2, 2::2]</code></li>
<li>(c) <code>r[2:4, 2:4]</code></li>
<li>(d) <code>r[[2, 3], [2, 3]]</code></li>
</ul>

<p><strong>Respuesta</strong>: (c)</p>

<pre><code class="language-python">r[2:4, 2:4]
</code></pre>

<pre><code>array([[14, 15],
       [20, 21]])
</code></pre>

          </div>

          



          
          <div class="article-widget">
            
<div class="post-nav">
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Siguiente</div>
    <a href="/courses/applied-data-science-with-python/curso1-modulo2/" rel="prev">Módulo 2</a>
  </div>
  
</div>

          </div>
          
        </div>

        <div class="body-footer">
          Última actualización el 2019-05-28
        </div>

      </article>

      <footer class="site-footer">
  

  <p class="powered-by">
    Alexis Sáez &copy;2019 &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
  </p>
</footer>


    </main>
  </div>
</div>


      

    
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
      

      
      
    

    
    

    
    
    
    <script id="dsq-count-scr" src="//infinitos-contrastes.disqus.com/count.js" async></script>
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Buscar...",
        'results': "resultados encontrados",
        'no_results': "No se encontraron resultados"
      };
      const content_type = {
        'post': "Artículos",
        'project': "Proyectos",
        'publication' : "Publicaciones",
        'talk' : "Charlas"
        };
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.1/anchor.min.js" integrity="sha256-pB/deHc9CGfFpJRjC43imB29Rse8tak+5eXqntO94ck=" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.9ef1b53ee2bde6c7f33b150c6ba4d452.js"></script>

    






  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Citar</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copiar
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Descargar
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
